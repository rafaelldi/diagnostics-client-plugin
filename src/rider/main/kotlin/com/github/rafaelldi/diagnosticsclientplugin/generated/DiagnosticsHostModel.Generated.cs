//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.11.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Linq;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using JetBrains.Annotations;

using JetBrains.Core;
using JetBrains.Diagnostics;
using JetBrains.Collections;
using JetBrains.Collections.Viewable;
using JetBrains.Lifetimes;
using JetBrains.Serialization;
using JetBrains.Rd;
using JetBrains.Rd.Base;
using JetBrains.Rd.Impl;
using JetBrains.Rd.Tasks;
using JetBrains.Rd.Util;
using JetBrains.Rd.Text;


// ReSharper disable RedundantEmptyObjectCreationArgumentList
// ReSharper disable InconsistentNaming
// ReSharper disable RedundantOverflowCheckingContext


namespace DiagnosticsAgent.Model
{
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:16</p>
  /// </summary>
  public class DiagnosticsHostModel : RdExtBase
  {
    //fields
    //public fields
    [NotNull] public DiagnosticsAgent.Model.ProcessList ProcessList {get; private set;}
    [NotNull] public IViewableMap<int, CounterSession> CounterSessions => _CounterSessions;
    [NotNull] public IViewableMap<int, GcEventSession> GcEventSessions => _GcEventSessions;
    [NotNull] public IViewableMap<int, TraceSession> TraceSessions => _TraceSessions;
    [NotNull] public IViewableMap<int, ChartSession> ChartSessions => _ChartSessions;
    [NotNull] public IRdEndpoint<CollectDumpCommand, DumpCollectionResult> CollectDump => _CollectDump;
    [NotNull] public IRdEndpoint<CollectStackTraceCommand, string> CollectStackTrace => _CollectStackTrace;
    [NotNull] public IRdEndpoint<CollectCounterCommand, CounterCollectionResult> CollectCounters => _CollectCounters;
    [NotNull] public IRdEndpoint<CollectGcEventCommand, GcEventCollectionResult> CollectGcEvents => _CollectGcEvents;
    [NotNull] public IRdEndpoint<CollectTraceCommand, TraceCollectionResult> CollectTraces => _CollectTraces;
    
    //private fields
    [NotNull] private readonly RdMap<int, CounterSession> _CounterSessions;
    [NotNull] private readonly RdMap<int, GcEventSession> _GcEventSessions;
    [NotNull] private readonly RdMap<int, TraceSession> _TraceSessions;
    [NotNull] private readonly RdMap<int, ChartSession> _ChartSessions;
    [NotNull] private readonly RdCall<CollectDumpCommand, DumpCollectionResult> _CollectDump;
    [NotNull] private readonly RdCall<CollectStackTraceCommand, string> _CollectStackTrace;
    [NotNull] private readonly RdCall<CollectCounterCommand, CounterCollectionResult> _CollectCounters;
    [NotNull] private readonly RdCall<CollectGcEventCommand, GcEventCollectionResult> _CollectGcEvents;
    [NotNull] private readonly RdCall<CollectTraceCommand, TraceCollectionResult> _CollectTraces;
    
    //primary constructor
    private DiagnosticsHostModel(
      [NotNull] DiagnosticsAgent.Model.ProcessList processList,
      [NotNull] RdMap<int, CounterSession> counterSessions,
      [NotNull] RdMap<int, GcEventSession> gcEventSessions,
      [NotNull] RdMap<int, TraceSession> traceSessions,
      [NotNull] RdMap<int, ChartSession> chartSessions,
      [NotNull] RdCall<CollectDumpCommand, DumpCollectionResult> collectDump,
      [NotNull] RdCall<CollectStackTraceCommand, string> collectStackTrace,
      [NotNull] RdCall<CollectCounterCommand, CounterCollectionResult> collectCounters,
      [NotNull] RdCall<CollectGcEventCommand, GcEventCollectionResult> collectGcEvents,
      [NotNull] RdCall<CollectTraceCommand, TraceCollectionResult> collectTraces
    )
    {
      if (processList == null) throw new ArgumentNullException("processList");
      if (counterSessions == null) throw new ArgumentNullException("counterSessions");
      if (gcEventSessions == null) throw new ArgumentNullException("gcEventSessions");
      if (traceSessions == null) throw new ArgumentNullException("traceSessions");
      if (chartSessions == null) throw new ArgumentNullException("chartSessions");
      if (collectDump == null) throw new ArgumentNullException("collectDump");
      if (collectStackTrace == null) throw new ArgumentNullException("collectStackTrace");
      if (collectCounters == null) throw new ArgumentNullException("collectCounters");
      if (collectGcEvents == null) throw new ArgumentNullException("collectGcEvents");
      if (collectTraces == null) throw new ArgumentNullException("collectTraces");
      
      ProcessList = processList;
      _CounterSessions = counterSessions;
      _GcEventSessions = gcEventSessions;
      _TraceSessions = traceSessions;
      _ChartSessions = chartSessions;
      _CollectDump = collectDump;
      _CollectStackTrace = collectStackTrace;
      _CollectCounters = collectCounters;
      _CollectGcEvents = collectGcEvents;
      _CollectTraces = collectTraces;
      BindableChildren.Add(new KeyValuePair<string, object>("processList", ProcessList));
      BindableChildren.Add(new KeyValuePair<string, object>("counterSessions", _CounterSessions));
      BindableChildren.Add(new KeyValuePair<string, object>("gcEventSessions", _GcEventSessions));
      BindableChildren.Add(new KeyValuePair<string, object>("traceSessions", _TraceSessions));
      BindableChildren.Add(new KeyValuePair<string, object>("chartSessions", _ChartSessions));
      BindableChildren.Add(new KeyValuePair<string, object>("collectDump", _CollectDump));
      BindableChildren.Add(new KeyValuePair<string, object>("collectStackTrace", _CollectStackTrace));
      BindableChildren.Add(new KeyValuePair<string, object>("collectCounters", _CollectCounters));
      BindableChildren.Add(new KeyValuePair<string, object>("collectGcEvents", _CollectGcEvents));
      BindableChildren.Add(new KeyValuePair<string, object>("collectTraces", _CollectTraces));
    }
    //secondary constructor
    private DiagnosticsHostModel (
    ) : this (
      new DiagnosticsAgent.Model.ProcessList(),
      new RdMap<int, CounterSession>(JetBrains.Rd.Impl.Serializers.ReadInt, JetBrains.Rd.Impl.Serializers.WriteInt, CounterSession.Read, CounterSession.Write),
      new RdMap<int, GcEventSession>(JetBrains.Rd.Impl.Serializers.ReadInt, JetBrains.Rd.Impl.Serializers.WriteInt, GcEventSession.Read, GcEventSession.Write),
      new RdMap<int, TraceSession>(JetBrains.Rd.Impl.Serializers.ReadInt, JetBrains.Rd.Impl.Serializers.WriteInt, TraceSession.Read, TraceSession.Write),
      new RdMap<int, ChartSession>(JetBrains.Rd.Impl.Serializers.ReadInt, JetBrains.Rd.Impl.Serializers.WriteInt, ChartSession.Read, ChartSession.Write),
      new RdCall<CollectDumpCommand, DumpCollectionResult>(CollectDumpCommand.Read, CollectDumpCommand.Write, DumpCollectionResult.Read, DumpCollectionResult.Write),
      new RdCall<CollectStackTraceCommand, string>(CollectStackTraceCommand.Read, CollectStackTraceCommand.Write, JetBrains.Rd.Impl.Serializers.ReadString, JetBrains.Rd.Impl.Serializers.WriteString),
      new RdCall<CollectCounterCommand, CounterCollectionResult>(CollectCounterCommand.Read, CollectCounterCommand.Write, CounterCollectionResult.Read, CounterCollectionResult.Write),
      new RdCall<CollectGcEventCommand, GcEventCollectionResult>(CollectGcEventCommand.Read, CollectGcEventCommand.Write, GcEventCollectionResult.Read, GcEventCollectionResult.Write),
      new RdCall<CollectTraceCommand, TraceCollectionResult>(CollectTraceCommand.Read, CollectTraceCommand.Write, TraceCollectionResult.Read, TraceCollectionResult.Write)
    ) {}
    //deconstruct trait
    //statics
    
    
    
    protected override long SerializationHash => -555981348305473068L;
    
    protected override Action<ISerializers> Register => RegisterDeclaredTypesSerializers;
    public static void RegisterDeclaredTypesSerializers(ISerializers serializers)
    {
      serializers.Register(CounterSession.Read, CounterSession.Write);
      serializers.Register(GcEventSession.Read, GcEventSession.Write);
      serializers.Register(TraceSession.Read, TraceSession.Write);
      serializers.Register(ChartSession.Read, ChartSession.Write);
      serializers.Register(Session_Unknown.Read, Session_Unknown.Write);
      
      serializers.RegisterToplevelOnce(typeof(DiagnosticsHostRoot), DiagnosticsHostRoot.RegisterDeclaredTypesSerializers);
    }
    
    public DiagnosticsHostModel(Lifetime lifetime, IProtocol protocol) : this()
    {
      Identify(protocol.Identities, RdId.Root.Mix("DiagnosticsHostModel"));
      this.BindTopLevel(lifetime, protocol, "DiagnosticsHostModel");
    }
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("DiagnosticsHostModel (");
      using (printer.IndentCookie()) {
        printer.Print("processList = "); ProcessList.PrintEx(printer); printer.Println();
        printer.Print("counterSessions = "); _CounterSessions.PrintEx(printer); printer.Println();
        printer.Print("gcEventSessions = "); _GcEventSessions.PrintEx(printer); printer.Println();
        printer.Print("traceSessions = "); _TraceSessions.PrintEx(printer); printer.Println();
        printer.Print("chartSessions = "); _ChartSessions.PrintEx(printer); printer.Println();
        printer.Print("collectDump = "); _CollectDump.PrintEx(printer); printer.Println();
        printer.Print("collectStackTrace = "); _CollectStackTrace.PrintEx(printer); printer.Println();
        printer.Print("collectCounters = "); _CollectCounters.PrintEx(printer); printer.Println();
        printer.Print("collectGcEvents = "); _CollectGcEvents.PrintEx(printer); printer.Println();
        printer.Print("collectTraces = "); _CollectTraces.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:105</p>
  /// </summary>
  public sealed class ChartEvent : IPrintable, IEquatable<ChartEvent>
  {
    //fields
    //public fields
    public long TimeStamp {get; private set;}
    public double Value {get; private set;}
    public ChartEventType Type {get; private set;}
    [CanBeNull] public string Label {get; private set;}
    
    //private fields
    //primary constructor
    public ChartEvent(
      long timeStamp,
      double value,
      ChartEventType type,
      [CanBeNull] string label
    )
    {
      TimeStamp = timeStamp;
      Value = value;
      Type = type;
      Label = label;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct(out long timeStamp, out double value, out ChartEventType type, [CanBeNull] out string label)
    {
      timeStamp = TimeStamp;
      value = Value;
      type = Type;
      label = Label;
    }
    //statics
    
    public static CtxReadDelegate<ChartEvent> Read = (ctx, reader) => 
    {
      var timeStamp = reader.ReadLong();
      var value = reader.ReadDouble();
      var type = (ChartEventType)reader.ReadInt();
      var label = ReadStringNullable(ctx, reader);
      var _result = new ChartEvent(timeStamp, value, type, label);
      return _result;
    };
    public static CtxReadDelegate<string> ReadStringNullable = JetBrains.Rd.Impl.Serializers.ReadString.NullableClass();
    
    public static CtxWriteDelegate<ChartEvent> Write = (ctx, writer, value) => 
    {
      writer.Write(value.TimeStamp);
      writer.Write(value.Value);
      writer.Write((int)value.Type);
      WriteStringNullable(ctx, writer, value.Label);
    };
    public static  CtxWriteDelegate<string> WriteStringNullable = JetBrains.Rd.Impl.Serializers.WriteString.NullableClass();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((ChartEvent) obj);
    }
    public bool Equals(ChartEvent other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return TimeStamp == other.TimeStamp && Value == other.Value && Type == other.Type && Equals(Label, other.Label);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + TimeStamp.GetHashCode();
        hash = hash * 31 + Value.GetHashCode();
        hash = hash * 31 + (int) Type;
        hash = hash * 31 + (Label != null ? Label.GetHashCode() : 0);
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("ChartEvent (");
      using (printer.IndentCookie()) {
        printer.Print("timeStamp = "); TimeStamp.PrintEx(printer); printer.Println();
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
        printer.Print("label = "); Label.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:112</p>
  /// </summary>
  public enum ChartEventType {
    Cpu,
    WorkingSet,
    GcHeapSize,
    Gc,
    Exception,
    ExceptionCount,
    ThreadCount
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:59</p>
  /// </summary>
  public sealed class ChartSession : Session
  {
    //fields
    //public fields
    [NotNull] public ISignal<ChartEvent> EventReceived => _EventReceived;
    
    //private fields
    [NotNull] private readonly RdSignal<ChartEvent> _EventReceived;
    
    //primary constructor
    private ChartSession(
      [NotNull] RdSignal<ChartEvent> eventReceived,
      [NotNull] RdProperty<bool> active,
      [NotNull] RdProperty<int?> duration
    ) : base (
      active,
      duration
     ) 
    {
      if (eventReceived == null) throw new ArgumentNullException("eventReceived");
      
      _EventReceived = eventReceived;
      _EventReceived.Async = true;
      BindableChildren.Add(new KeyValuePair<string, object>("eventReceived", _EventReceived));
    }
    //secondary constructor
    public ChartSession (
    ) : this (
      new RdSignal<ChartEvent>(ChartEvent.Read, ChartEvent.Write),
      new RdProperty<bool>(JetBrains.Rd.Impl.Serializers.ReadBool, JetBrains.Rd.Impl.Serializers.WriteBool),
      new RdProperty<int?>(ReadIntNullable, WriteIntNullable)
    ) {}
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<ChartSession> Read = (ctx, reader) => 
    {
      var _id = RdId.Read(reader);
      var active = RdProperty<bool>.Read(ctx, reader, JetBrains.Rd.Impl.Serializers.ReadBool, JetBrains.Rd.Impl.Serializers.WriteBool);
      var duration = RdProperty<int?>.Read(ctx, reader, ReadIntNullable, WriteIntNullable);
      var eventReceived = RdSignal<ChartEvent>.Read(ctx, reader, ChartEvent.Read, ChartEvent.Write);
      var _result = new ChartSession(eventReceived, active, duration).WithId(_id);
      return _result;
    };
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static new CtxWriteDelegate<ChartSession> Write = (ctx, writer, value) => 
    {
      value.RdId.Write(writer);
      RdProperty<bool>.Write(ctx, writer, value._Active);
      RdProperty<int?>.Write(ctx, writer, value._Duration);
      RdSignal<ChartEvent>.Write(ctx, writer, value._EventReceived);
    };
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("ChartSession (");
      using (printer.IndentCookie()) {
        printer.Print("eventReceived = "); _EventReceived.PrintEx(printer); printer.Println();
        printer.Print("active = "); _Active.PrintEx(printer); printer.Println();
        printer.Print("duration = "); _Duration.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:157</p>
  /// </summary>
  public sealed class CollectCounterCommand : IPrintable, IEquatable<CollectCounterCommand>
  {
    //fields
    //public fields
    public int Pid {get; private set;}
    [CanBeNull] public int? Duration {get; private set;}
    [NotNull] public string ExportFilePath {get; private set;}
    public CounterFileFormat Format {get; private set;}
    public int RefreshInterval {get; private set;}
    [NotNull] public string Providers {get; private set;}
    [CanBeNull] public string Metrics {get; private set;}
    public int MaxTimeSeries {get; private set;}
    public int MaxHistograms {get; private set;}
    
    //private fields
    //primary constructor
    public CollectCounterCommand(
      int pid,
      [CanBeNull] int? duration,
      [NotNull] string exportFilePath,
      CounterFileFormat format,
      int refreshInterval,
      [NotNull] string providers,
      [CanBeNull] string metrics,
      int maxTimeSeries,
      int maxHistograms
    )
    {
      if (exportFilePath == null) throw new ArgumentNullException("exportFilePath");
      if (providers == null) throw new ArgumentNullException("providers");
      
      Pid = pid;
      Duration = duration;
      ExportFilePath = exportFilePath;
      Format = format;
      RefreshInterval = refreshInterval;
      Providers = providers;
      Metrics = metrics;
      MaxTimeSeries = maxTimeSeries;
      MaxHistograms = maxHistograms;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct(out int pid, [CanBeNull] out int? duration, [NotNull] out string exportFilePath, out CounterFileFormat format, out int refreshInterval, [NotNull] out string providers, [CanBeNull] out string metrics, out int maxTimeSeries, out int maxHistograms)
    {
      pid = Pid;
      duration = Duration;
      exportFilePath = ExportFilePath;
      format = Format;
      refreshInterval = RefreshInterval;
      providers = Providers;
      metrics = Metrics;
      maxTimeSeries = MaxTimeSeries;
      maxHistograms = MaxHistograms;
    }
    //statics
    
    public static CtxReadDelegate<CollectCounterCommand> Read = (ctx, reader) => 
    {
      var pid = reader.ReadInt();
      var duration = ReadIntNullable(ctx, reader);
      var exportFilePath = reader.ReadString();
      var format = (CounterFileFormat)reader.ReadInt();
      var refreshInterval = reader.ReadInt();
      var providers = reader.ReadString();
      var metrics = ReadStringNullable(ctx, reader);
      var maxTimeSeries = reader.ReadInt();
      var maxHistograms = reader.ReadInt();
      var _result = new CollectCounterCommand(pid, duration, exportFilePath, format, refreshInterval, providers, metrics, maxTimeSeries, maxHistograms);
      return _result;
    };
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    public static CtxReadDelegate<string> ReadStringNullable = JetBrains.Rd.Impl.Serializers.ReadString.NullableClass();
    
    public static CtxWriteDelegate<CollectCounterCommand> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Pid);
      WriteIntNullable(ctx, writer, value.Duration);
      writer.Write(value.ExportFilePath);
      writer.Write((int)value.Format);
      writer.Write(value.RefreshInterval);
      writer.Write(value.Providers);
      WriteStringNullable(ctx, writer, value.Metrics);
      writer.Write(value.MaxTimeSeries);
      writer.Write(value.MaxHistograms);
    };
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    public static  CtxWriteDelegate<string> WriteStringNullable = JetBrains.Rd.Impl.Serializers.WriteString.NullableClass();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((CollectCounterCommand) obj);
    }
    public bool Equals(CollectCounterCommand other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Pid == other.Pid && Equals(Duration, other.Duration) && ExportFilePath == other.ExportFilePath && Format == other.Format && RefreshInterval == other.RefreshInterval && Providers == other.Providers && Equals(Metrics, other.Metrics) && MaxTimeSeries == other.MaxTimeSeries && MaxHistograms == other.MaxHistograms;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Pid.GetHashCode();
        hash = hash * 31 + (Duration != null ? Duration.GetHashCode() : 0);
        hash = hash * 31 + ExportFilePath.GetHashCode();
        hash = hash * 31 + (int) Format;
        hash = hash * 31 + RefreshInterval.GetHashCode();
        hash = hash * 31 + Providers.GetHashCode();
        hash = hash * 31 + (Metrics != null ? Metrics.GetHashCode() : 0);
        hash = hash * 31 + MaxTimeSeries.GetHashCode();
        hash = hash * 31 + MaxHistograms.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("CollectCounterCommand (");
      using (printer.IndentCookie()) {
        printer.Print("pid = "); Pid.PrintEx(printer); printer.Println();
        printer.Print("duration = "); Duration.PrintEx(printer); printer.Println();
        printer.Print("exportFilePath = "); ExportFilePath.PrintEx(printer); printer.Println();
        printer.Print("format = "); Format.PrintEx(printer); printer.Println();
        printer.Print("refreshInterval = "); RefreshInterval.PrintEx(printer); printer.Println();
        printer.Print("providers = "); Providers.PrintEx(printer); printer.Println();
        printer.Print("metrics = "); Metrics.PrintEx(printer); printer.Println();
        printer.Print("maxTimeSeries = "); MaxTimeSeries.PrintEx(printer); printer.Println();
        printer.Print("maxHistograms = "); MaxHistograms.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:131</p>
  /// </summary>
  public sealed class CollectDumpCommand : IPrintable, IEquatable<CollectDumpCommand>
  {
    //fields
    //public fields
    public int Pid {get; private set;}
    public DumpType Type {get; private set;}
    [NotNull] public string OutFolder {get; private set;}
    [NotNull] public string Filename {get; private set;}
    public bool Diag {get; private set;}
    
    //private fields
    //primary constructor
    public CollectDumpCommand(
      int pid,
      DumpType type,
      [NotNull] string outFolder,
      [NotNull] string filename,
      bool diag
    )
    {
      if (outFolder == null) throw new ArgumentNullException("outFolder");
      if (filename == null) throw new ArgumentNullException("filename");
      
      Pid = pid;
      Type = type;
      OutFolder = outFolder;
      Filename = filename;
      Diag = diag;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct(out int pid, out DumpType type, [NotNull] out string outFolder, [NotNull] out string filename, out bool diag)
    {
      pid = Pid;
      type = Type;
      outFolder = OutFolder;
      filename = Filename;
      diag = Diag;
    }
    //statics
    
    public static CtxReadDelegate<CollectDumpCommand> Read = (ctx, reader) => 
    {
      var pid = reader.ReadInt();
      var type = (DumpType)reader.ReadInt();
      var outFolder = reader.ReadString();
      var filename = reader.ReadString();
      var diag = reader.ReadBool();
      var _result = new CollectDumpCommand(pid, type, outFolder, filename, diag);
      return _result;
    };
    
    public static CtxWriteDelegate<CollectDumpCommand> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Pid);
      writer.Write((int)value.Type);
      writer.Write(value.OutFolder);
      writer.Write(value.Filename);
      writer.Write(value.Diag);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((CollectDumpCommand) obj);
    }
    public bool Equals(CollectDumpCommand other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Pid == other.Pid && Type == other.Type && OutFolder == other.OutFolder && Filename == other.Filename && Diag == other.Diag;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Pid.GetHashCode();
        hash = hash * 31 + (int) Type;
        hash = hash * 31 + OutFolder.GetHashCode();
        hash = hash * 31 + Filename.GetHashCode();
        hash = hash * 31 + Diag.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("CollectDumpCommand (");
      using (printer.IndentCookie()) {
        printer.Print("pid = "); Pid.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
        printer.Print("outFolder = "); OutFolder.PrintEx(printer); printer.Println();
        printer.Print("filename = "); Filename.PrintEx(printer); printer.Println();
        printer.Print("diag = "); Diag.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:177</p>
  /// </summary>
  public sealed class CollectGcEventCommand : IPrintable, IEquatable<CollectGcEventCommand>
  {
    //fields
    //public fields
    public int Pid {get; private set;}
    [CanBeNull] public int? Duration {get; private set;}
    [NotNull] public string ExportFilePath {get; private set;}
    
    //private fields
    //primary constructor
    public CollectGcEventCommand(
      int pid,
      [CanBeNull] int? duration,
      [NotNull] string exportFilePath
    )
    {
      if (exportFilePath == null) throw new ArgumentNullException("exportFilePath");
      
      Pid = pid;
      Duration = duration;
      ExportFilePath = exportFilePath;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct(out int pid, [CanBeNull] out int? duration, [NotNull] out string exportFilePath)
    {
      pid = Pid;
      duration = Duration;
      exportFilePath = ExportFilePath;
    }
    //statics
    
    public static CtxReadDelegate<CollectGcEventCommand> Read = (ctx, reader) => 
    {
      var pid = reader.ReadInt();
      var duration = ReadIntNullable(ctx, reader);
      var exportFilePath = reader.ReadString();
      var _result = new CollectGcEventCommand(pid, duration, exportFilePath);
      return _result;
    };
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static CtxWriteDelegate<CollectGcEventCommand> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Pid);
      WriteIntNullable(ctx, writer, value.Duration);
      writer.Write(value.ExportFilePath);
    };
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((CollectGcEventCommand) obj);
    }
    public bool Equals(CollectGcEventCommand other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Pid == other.Pid && Equals(Duration, other.Duration) && ExportFilePath == other.ExportFilePath;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Pid.GetHashCode();
        hash = hash * 31 + (Duration != null ? Duration.GetHashCode() : 0);
        hash = hash * 31 + ExportFilePath.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("CollectGcEventCommand (");
      using (printer.IndentCookie()) {
        printer.Print("pid = "); Pid.PrintEx(printer); printer.Println();
        printer.Print("duration = "); Duration.PrintEx(printer); printer.Println();
        printer.Print("exportFilePath = "); ExportFilePath.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:149</p>
  /// </summary>
  public sealed class CollectStackTraceCommand : IPrintable, IEquatable<CollectStackTraceCommand>
  {
    //fields
    //public fields
    public int Pid {get; private set;}
    
    //private fields
    //primary constructor
    public CollectStackTraceCommand(
      int pid
    )
    {
      Pid = pid;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct(out int pid)
    {
      pid = Pid;
    }
    //statics
    
    public static CtxReadDelegate<CollectStackTraceCommand> Read = (ctx, reader) => 
    {
      var pid = reader.ReadInt();
      var _result = new CollectStackTraceCommand(pid);
      return _result;
    };
    
    public static CtxWriteDelegate<CollectStackTraceCommand> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Pid);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((CollectStackTraceCommand) obj);
    }
    public bool Equals(CollectStackTraceCommand other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Pid == other.Pid;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Pid.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("CollectStackTraceCommand (");
      using (printer.IndentCookie()) {
        printer.Print("pid = "); Pid.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:188</p>
  /// </summary>
  public sealed class CollectTraceCommand : IPrintable, IEquatable<CollectTraceCommand>
  {
    //fields
    //public fields
    public int Pid {get; private set;}
    [CanBeNull] public int? Duration {get; private set;}
    [NotNull] public string ExportFilePath {get; private set;}
    public TracingProfile Profile {get; private set;}
    [NotNull] public string Providers {get; private set;}
    [NotNull] public List<PredefinedProvider> PredefinedProviders {get; private set;}
    
    //private fields
    //primary constructor
    public CollectTraceCommand(
      int pid,
      [CanBeNull] int? duration,
      [NotNull] string exportFilePath,
      TracingProfile profile,
      [NotNull] string providers,
      [NotNull] List<PredefinedProvider> predefinedProviders
    )
    {
      if (exportFilePath == null) throw new ArgumentNullException("exportFilePath");
      if (providers == null) throw new ArgumentNullException("providers");
      if (predefinedProviders == null) throw new ArgumentNullException("predefinedProviders");
      
      Pid = pid;
      Duration = duration;
      ExportFilePath = exportFilePath;
      Profile = profile;
      Providers = providers;
      PredefinedProviders = predefinedProviders;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct(out int pid, [CanBeNull] out int? duration, [NotNull] out string exportFilePath, out TracingProfile profile, [NotNull] out string providers, [NotNull] out List<PredefinedProvider> predefinedProviders)
    {
      pid = Pid;
      duration = Duration;
      exportFilePath = ExportFilePath;
      profile = Profile;
      providers = Providers;
      predefinedProviders = PredefinedProviders;
    }
    //statics
    
    public static CtxReadDelegate<CollectTraceCommand> Read = (ctx, reader) => 
    {
      var pid = reader.ReadInt();
      var duration = ReadIntNullable(ctx, reader);
      var exportFilePath = reader.ReadString();
      var profile = (TracingProfile)reader.ReadInt();
      var providers = reader.ReadString();
      var predefinedProviders = ReadPredefinedProviderList(ctx, reader);
      var _result = new CollectTraceCommand(pid, duration, exportFilePath, profile, providers, predefinedProviders);
      return _result;
    };
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    public static CtxReadDelegate<List<PredefinedProvider>> ReadPredefinedProviderList = new CtxReadDelegate<PredefinedProvider>(JetBrains.Rd.Impl.Serializers.ReadEnum<PredefinedProvider>).List();
    
    public static CtxWriteDelegate<CollectTraceCommand> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Pid);
      WriteIntNullable(ctx, writer, value.Duration);
      writer.Write(value.ExportFilePath);
      writer.Write((int)value.Profile);
      writer.Write(value.Providers);
      WritePredefinedProviderList(ctx, writer, value.PredefinedProviders);
    };
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    public static  CtxWriteDelegate<List<PredefinedProvider>> WritePredefinedProviderList = new CtxWriteDelegate<PredefinedProvider>(JetBrains.Rd.Impl.Serializers.WriteEnum<PredefinedProvider>).List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((CollectTraceCommand) obj);
    }
    public bool Equals(CollectTraceCommand other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Pid == other.Pid && Equals(Duration, other.Duration) && ExportFilePath == other.ExportFilePath && Profile == other.Profile && Providers == other.Providers && PredefinedProviders.SequenceEqual(other.PredefinedProviders);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Pid.GetHashCode();
        hash = hash * 31 + (Duration != null ? Duration.GetHashCode() : 0);
        hash = hash * 31 + ExportFilePath.GetHashCode();
        hash = hash * 31 + (int) Profile;
        hash = hash * 31 + Providers.GetHashCode();
        hash = hash * 31 + PredefinedProviders.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("CollectTraceCommand (");
      using (printer.IndentCookie()) {
        printer.Print("pid = "); Pid.PrintEx(printer); printer.Println();
        printer.Print("duration = "); Duration.PrintEx(printer); printer.Println();
        printer.Print("exportFilePath = "); ExportFilePath.PrintEx(printer); printer.Println();
        printer.Print("profile = "); Profile.PrintEx(printer); printer.Println();
        printer.Print("providers = "); Providers.PrintEx(printer); printer.Println();
        printer.Print("predefinedProviders = "); PredefinedProviders.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:63</p>
  /// </summary>
  public sealed class Counter : IPrintable, IEquatable<Counter>
  {
    //fields
    //public fields
    [NotNull] public string Name {get; private set;}
    [CanBeNull] public string Tags {get; private set;}
    public double Value {get; private set;}
    
    //private fields
    //primary constructor
    public Counter(
      [NotNull] string name,
      [CanBeNull] string tags,
      double value
    )
    {
      if (name == null) throw new ArgumentNullException("name");
      
      Name = name;
      Tags = tags;
      Value = value;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string name, [CanBeNull] out string tags, out double value)
    {
      name = Name;
      tags = Tags;
      value = Value;
    }
    //statics
    
    public static CtxReadDelegate<Counter> Read = (ctx, reader) => 
    {
      var name = reader.ReadString();
      var tags = ReadStringNullable(ctx, reader);
      var value = reader.ReadDouble();
      var _result = new Counter(name, tags, value);
      return _result;
    };
    public static CtxReadDelegate<string> ReadStringNullable = JetBrains.Rd.Impl.Serializers.ReadString.NullableClass();
    
    public static CtxWriteDelegate<Counter> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Name);
      WriteStringNullable(ctx, writer, value.Tags);
      writer.Write(value.Value);
    };
    public static  CtxWriteDelegate<string> WriteStringNullable = JetBrains.Rd.Impl.Serializers.WriteString.NullableClass();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((Counter) obj);
    }
    public bool Equals(Counter other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Name == other.Name && Equals(Tags, other.Tags) && Value == other.Value;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + (Tags != null ? Tags.GetHashCode() : 0);
        hash = hash * 31 + Value.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("Counter (");
      using (printer.IndentCookie()) {
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("tags = "); Tags.PrintEx(printer); printer.Println();
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:170</p>
  /// </summary>
  public sealed class CounterCollectionResult : IPrintable, IEquatable<CounterCollectionResult>
  {
    //fields
    //public fields
    [NotNull] public string FilePath {get; private set;}
    
    //private fields
    //primary constructor
    public CounterCollectionResult(
      [NotNull] string filePath
    )
    {
      if (filePath == null) throw new ArgumentNullException("filePath");
      
      FilePath = filePath;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string filePath)
    {
      filePath = FilePath;
    }
    //statics
    
    public static CtxReadDelegate<CounterCollectionResult> Read = (ctx, reader) => 
    {
      var filePath = reader.ReadString();
      var _result = new CounterCollectionResult(filePath);
      return _result;
    };
    
    public static CtxWriteDelegate<CounterCollectionResult> Write = (ctx, writer, value) => 
    {
      writer.Write(value.FilePath);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((CounterCollectionResult) obj);
    }
    public bool Equals(CounterCollectionResult other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return FilePath == other.FilePath;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + FilePath.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("CounterCollectionResult (");
      using (printer.IndentCookie()) {
        printer.Print("filePath = "); FilePath.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:161</p>
  /// </summary>
  public enum CounterFileFormat {
    Csv,
    Json
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:41</p>
  /// </summary>
  public sealed class CounterSession : Session
  {
    //fields
    //public fields
    [NotNull] public ISignal<Counter> CounterReceived => _CounterReceived;
    public int RefreshInterval {get; private set;}
    [NotNull] public string Providers {get; private set;}
    [CanBeNull] public string Metrics {get; private set;}
    public int MaxTimeSeries {get; private set;}
    public int MaxHistograms {get; private set;}
    
    //private fields
    [NotNull] private readonly RdSignal<Counter> _CounterReceived;
    
    //primary constructor
    private CounterSession(
      [NotNull] RdSignal<Counter> counterReceived,
      int refreshInterval,
      [NotNull] string providers,
      [CanBeNull] string metrics,
      int maxTimeSeries,
      int maxHistograms,
      [NotNull] RdProperty<bool> active,
      [NotNull] RdProperty<int?> duration
    ) : base (
      active,
      duration
     ) 
    {
      if (counterReceived == null) throw new ArgumentNullException("counterReceived");
      if (providers == null) throw new ArgumentNullException("providers");
      
      _CounterReceived = counterReceived;
      RefreshInterval = refreshInterval;
      Providers = providers;
      Metrics = metrics;
      MaxTimeSeries = maxTimeSeries;
      MaxHistograms = maxHistograms;
      _CounterReceived.Async = true;
      BindableChildren.Add(new KeyValuePair<string, object>("counterReceived", _CounterReceived));
    }
    //secondary constructor
    public CounterSession (
      int refreshInterval,
      [NotNull] string providers,
      [CanBeNull] string metrics,
      int maxTimeSeries,
      int maxHistograms
    ) : this (
      new RdSignal<Counter>(Counter.Read, Counter.Write),
      refreshInterval,
      providers,
      metrics,
      maxTimeSeries,
      maxHistograms,
      new RdProperty<bool>(JetBrains.Rd.Impl.Serializers.ReadBool, JetBrains.Rd.Impl.Serializers.WriteBool),
      new RdProperty<int?>(ReadIntNullable, WriteIntNullable)
    ) {}
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<CounterSession> Read = (ctx, reader) => 
    {
      var _id = RdId.Read(reader);
      var active = RdProperty<bool>.Read(ctx, reader, JetBrains.Rd.Impl.Serializers.ReadBool, JetBrains.Rd.Impl.Serializers.WriteBool);
      var duration = RdProperty<int?>.Read(ctx, reader, ReadIntNullable, WriteIntNullable);
      var counterReceived = RdSignal<Counter>.Read(ctx, reader, Counter.Read, Counter.Write);
      var refreshInterval = reader.ReadInt();
      var providers = reader.ReadString();
      var metrics = ReadStringNullable(ctx, reader);
      var maxTimeSeries = reader.ReadInt();
      var maxHistograms = reader.ReadInt();
      var _result = new CounterSession(counterReceived, refreshInterval, providers, metrics, maxTimeSeries, maxHistograms, active, duration).WithId(_id);
      return _result;
    };
    public static CtxReadDelegate<string> ReadStringNullable = JetBrains.Rd.Impl.Serializers.ReadString.NullableClass();
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static new CtxWriteDelegate<CounterSession> Write = (ctx, writer, value) => 
    {
      value.RdId.Write(writer);
      RdProperty<bool>.Write(ctx, writer, value._Active);
      RdProperty<int?>.Write(ctx, writer, value._Duration);
      RdSignal<Counter>.Write(ctx, writer, value._CounterReceived);
      writer.Write(value.RefreshInterval);
      writer.Write(value.Providers);
      WriteStringNullable(ctx, writer, value.Metrics);
      writer.Write(value.MaxTimeSeries);
      writer.Write(value.MaxHistograms);
    };
    public static  CtxWriteDelegate<string> WriteStringNullable = JetBrains.Rd.Impl.Serializers.WriteString.NullableClass();
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("CounterSession (");
      using (printer.IndentCookie()) {
        printer.Print("counterReceived = "); _CounterReceived.PrintEx(printer); printer.Println();
        printer.Print("refreshInterval = "); RefreshInterval.PrintEx(printer); printer.Println();
        printer.Print("providers = "); Providers.PrintEx(printer); printer.Println();
        printer.Print("metrics = "); Metrics.PrintEx(printer); printer.Println();
        printer.Print("maxTimeSeries = "); MaxTimeSeries.PrintEx(printer); printer.Println();
        printer.Print("maxHistograms = "); MaxHistograms.PrintEx(printer); printer.Println();
        printer.Print("active = "); _Active.PrintEx(printer); printer.Println();
        printer.Print("duration = "); _Duration.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:142</p>
  /// </summary>
  public sealed class DumpCollectionResult : IPrintable, IEquatable<DumpCollectionResult>
  {
    //fields
    //public fields
    [NotNull] public string FilePath {get; private set;}
    
    //private fields
    //primary constructor
    public DumpCollectionResult(
      [NotNull] string filePath
    )
    {
      if (filePath == null) throw new ArgumentNullException("filePath");
      
      FilePath = filePath;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string filePath)
    {
      filePath = FilePath;
    }
    //statics
    
    public static CtxReadDelegate<DumpCollectionResult> Read = (ctx, reader) => 
    {
      var filePath = reader.ReadString();
      var _result = new DumpCollectionResult(filePath);
      return _result;
    };
    
    public static CtxWriteDelegate<DumpCollectionResult> Write = (ctx, writer, value) => 
    {
      writer.Write(value.FilePath);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((DumpCollectionResult) obj);
    }
    public bool Equals(DumpCollectionResult other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return FilePath == other.FilePath;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + FilePath.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("DumpCollectionResult (");
      using (printer.IndentCookie()) {
        printer.Print("filePath = "); FilePath.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:133</p>
  /// </summary>
  public enum DumpType {
    Full,
    Heap,
    Triage,
    Mini
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:69</p>
  /// </summary>
  public sealed class GcEvent : IPrintable, IEquatable<GcEvent>
  {
    //fields
    //public fields
    public int Number {get; private set;}
    [NotNull] public string Generation {get; private set;}
    [NotNull] public string Reason {get; private set;}
    public double PauseDuration {get; private set;}
    public double Peak {get; private set;}
    public double After {get; private set;}
    public double Ratio {get; private set;}
    public double Promoted {get; private set;}
    public double Allocated {get; private set;}
    public double AllocationRate {get; private set;}
    public double SizeGen0 {get; private set;}
    public double SizeGen1 {get; private set;}
    public double SizeGen2 {get; private set;}
    public double SizeLoh {get; private set;}
    public int PinnedObjects {get; private set;}
    
    //private fields
    //primary constructor
    public GcEvent(
      int number,
      [NotNull] string generation,
      [NotNull] string reason,
      double pauseDuration,
      double peak,
      double after,
      double ratio,
      double promoted,
      double allocated,
      double allocationRate,
      double sizeGen0,
      double sizeGen1,
      double sizeGen2,
      double sizeLoh,
      int pinnedObjects
    )
    {
      if (generation == null) throw new ArgumentNullException("generation");
      if (reason == null) throw new ArgumentNullException("reason");
      
      Number = number;
      Generation = generation;
      Reason = reason;
      PauseDuration = pauseDuration;
      Peak = peak;
      After = after;
      Ratio = ratio;
      Promoted = promoted;
      Allocated = allocated;
      AllocationRate = allocationRate;
      SizeGen0 = sizeGen0;
      SizeGen1 = sizeGen1;
      SizeGen2 = sizeGen2;
      SizeLoh = sizeLoh;
      PinnedObjects = pinnedObjects;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct(out int number, [NotNull] out string generation, [NotNull] out string reason, out double pauseDuration, out double peak, out double after, out double ratio, out double promoted, out double allocated, out double allocationRate, out double sizeGen0, out double sizeGen1, out double sizeGen2, out double sizeLoh, out int pinnedObjects)
    {
      number = Number;
      generation = Generation;
      reason = Reason;
      pauseDuration = PauseDuration;
      peak = Peak;
      after = After;
      ratio = Ratio;
      promoted = Promoted;
      allocated = Allocated;
      allocationRate = AllocationRate;
      sizeGen0 = SizeGen0;
      sizeGen1 = SizeGen1;
      sizeGen2 = SizeGen2;
      sizeLoh = SizeLoh;
      pinnedObjects = PinnedObjects;
    }
    //statics
    
    public static CtxReadDelegate<GcEvent> Read = (ctx, reader) => 
    {
      var number = reader.ReadInt();
      var generation = reader.ReadString();
      var reason = reader.ReadString();
      var pauseDuration = reader.ReadDouble();
      var peak = reader.ReadDouble();
      var after = reader.ReadDouble();
      var ratio = reader.ReadDouble();
      var promoted = reader.ReadDouble();
      var allocated = reader.ReadDouble();
      var allocationRate = reader.ReadDouble();
      var sizeGen0 = reader.ReadDouble();
      var sizeGen1 = reader.ReadDouble();
      var sizeGen2 = reader.ReadDouble();
      var sizeLoh = reader.ReadDouble();
      var pinnedObjects = reader.ReadInt();
      var _result = new GcEvent(number, generation, reason, pauseDuration, peak, after, ratio, promoted, allocated, allocationRate, sizeGen0, sizeGen1, sizeGen2, sizeLoh, pinnedObjects);
      return _result;
    };
    
    public static CtxWriteDelegate<GcEvent> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Number);
      writer.Write(value.Generation);
      writer.Write(value.Reason);
      writer.Write(value.PauseDuration);
      writer.Write(value.Peak);
      writer.Write(value.After);
      writer.Write(value.Ratio);
      writer.Write(value.Promoted);
      writer.Write(value.Allocated);
      writer.Write(value.AllocationRate);
      writer.Write(value.SizeGen0);
      writer.Write(value.SizeGen1);
      writer.Write(value.SizeGen2);
      writer.Write(value.SizeLoh);
      writer.Write(value.PinnedObjects);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((GcEvent) obj);
    }
    public bool Equals(GcEvent other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Number == other.Number && Generation == other.Generation && Reason == other.Reason && PauseDuration == other.PauseDuration && Peak == other.Peak && After == other.After && Ratio == other.Ratio && Promoted == other.Promoted && Allocated == other.Allocated && AllocationRate == other.AllocationRate && SizeGen0 == other.SizeGen0 && SizeGen1 == other.SizeGen1 && SizeGen2 == other.SizeGen2 && SizeLoh == other.SizeLoh && PinnedObjects == other.PinnedObjects;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Number.GetHashCode();
        hash = hash * 31 + Generation.GetHashCode();
        hash = hash * 31 + Reason.GetHashCode();
        hash = hash * 31 + PauseDuration.GetHashCode();
        hash = hash * 31 + Peak.GetHashCode();
        hash = hash * 31 + After.GetHashCode();
        hash = hash * 31 + Ratio.GetHashCode();
        hash = hash * 31 + Promoted.GetHashCode();
        hash = hash * 31 + Allocated.GetHashCode();
        hash = hash * 31 + AllocationRate.GetHashCode();
        hash = hash * 31 + SizeGen0.GetHashCode();
        hash = hash * 31 + SizeGen1.GetHashCode();
        hash = hash * 31 + SizeGen2.GetHashCode();
        hash = hash * 31 + SizeLoh.GetHashCode();
        hash = hash * 31 + PinnedObjects.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("GcEvent (");
      using (printer.IndentCookie()) {
        printer.Print("number = "); Number.PrintEx(printer); printer.Println();
        printer.Print("generation = "); Generation.PrintEx(printer); printer.Println();
        printer.Print("reason = "); Reason.PrintEx(printer); printer.Println();
        printer.Print("pauseDuration = "); PauseDuration.PrintEx(printer); printer.Println();
        printer.Print("peak = "); Peak.PrintEx(printer); printer.Println();
        printer.Print("after = "); After.PrintEx(printer); printer.Println();
        printer.Print("ratio = "); Ratio.PrintEx(printer); printer.Println();
        printer.Print("promoted = "); Promoted.PrintEx(printer); printer.Println();
        printer.Print("allocated = "); Allocated.PrintEx(printer); printer.Println();
        printer.Print("allocationRate = "); AllocationRate.PrintEx(printer); printer.Println();
        printer.Print("sizeGen0 = "); SizeGen0.PrintEx(printer); printer.Println();
        printer.Print("sizeGen1 = "); SizeGen1.PrintEx(printer); printer.Println();
        printer.Print("sizeGen2 = "); SizeGen2.PrintEx(printer); printer.Println();
        printer.Print("sizeLoh = "); SizeLoh.PrintEx(printer); printer.Println();
        printer.Print("pinnedObjects = "); PinnedObjects.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:181</p>
  /// </summary>
  public sealed class GcEventCollectionResult : IPrintable, IEquatable<GcEventCollectionResult>
  {
    //fields
    //public fields
    [NotNull] public string FilePath {get; private set;}
    
    //private fields
    //primary constructor
    public GcEventCollectionResult(
      [NotNull] string filePath
    )
    {
      if (filePath == null) throw new ArgumentNullException("filePath");
      
      FilePath = filePath;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string filePath)
    {
      filePath = FilePath;
    }
    //statics
    
    public static CtxReadDelegate<GcEventCollectionResult> Read = (ctx, reader) => 
    {
      var filePath = reader.ReadString();
      var _result = new GcEventCollectionResult(filePath);
      return _result;
    };
    
    public static CtxWriteDelegate<GcEventCollectionResult> Write = (ctx, writer, value) => 
    {
      writer.Write(value.FilePath);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((GcEventCollectionResult) obj);
    }
    public bool Equals(GcEventCollectionResult other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return FilePath == other.FilePath;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + FilePath.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("GcEventCollectionResult (");
      using (printer.IndentCookie()) {
        printer.Print("filePath = "); FilePath.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:50</p>
  /// </summary>
  public sealed class GcEventSession : Session
  {
    //fields
    //public fields
    [NotNull] public ISignal<GcEvent> GcHappened => _GcHappened;
    
    //private fields
    [NotNull] private readonly RdSignal<GcEvent> _GcHappened;
    
    //primary constructor
    private GcEventSession(
      [NotNull] RdSignal<GcEvent> gcHappened,
      [NotNull] RdProperty<bool> active,
      [NotNull] RdProperty<int?> duration
    ) : base (
      active,
      duration
     ) 
    {
      if (gcHappened == null) throw new ArgumentNullException("gcHappened");
      
      _GcHappened = gcHappened;
      _GcHappened.Async = true;
      BindableChildren.Add(new KeyValuePair<string, object>("gcHappened", _GcHappened));
    }
    //secondary constructor
    public GcEventSession (
    ) : this (
      new RdSignal<GcEvent>(GcEvent.Read, GcEvent.Write),
      new RdProperty<bool>(JetBrains.Rd.Impl.Serializers.ReadBool, JetBrains.Rd.Impl.Serializers.WriteBool),
      new RdProperty<int?>(ReadIntNullable, WriteIntNullable)
    ) {}
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<GcEventSession> Read = (ctx, reader) => 
    {
      var _id = RdId.Read(reader);
      var active = RdProperty<bool>.Read(ctx, reader, JetBrains.Rd.Impl.Serializers.ReadBool, JetBrains.Rd.Impl.Serializers.WriteBool);
      var duration = RdProperty<int?>.Read(ctx, reader, ReadIntNullable, WriteIntNullable);
      var gcHappened = RdSignal<GcEvent>.Read(ctx, reader, GcEvent.Read, GcEvent.Write);
      var _result = new GcEventSession(gcHappened, active, duration).WithId(_id);
      return _result;
    };
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static new CtxWriteDelegate<GcEventSession> Write = (ctx, writer, value) => 
    {
      value.RdId.Write(writer);
      RdProperty<bool>.Write(ctx, writer, value._Active);
      RdProperty<int?>.Write(ctx, writer, value._Duration);
      RdSignal<GcEvent>.Write(ctx, writer, value._GcHappened);
    };
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("GcEventSession (");
      using (printer.IndentCookie()) {
        printer.Print("gcHappened = "); _GcHappened.PrintEx(printer); printer.Println();
        printer.Print("active = "); _Active.PrintEx(printer); printer.Println();
        printer.Print("duration = "); _Duration.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:87</p>
  /// </summary>
  public enum PredefinedProvider {
    Http,
    AspNet,
    EF,
    Exceptions,
    Threads,
    Contentions,
    Tasks,
    Loader
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:17</p>
  /// </summary>
  public sealed class ProcessEnvironmentVariable : IPrintable, IEquatable<ProcessEnvironmentVariable>
  {
    //fields
    //public fields
    [NotNull] public string Key {get; private set;}
    [NotNull] public string Value {get; private set;}
    
    //private fields
    //primary constructor
    public ProcessEnvironmentVariable(
      [NotNull] string key,
      [NotNull] string value
    )
    {
      if (key == null) throw new ArgumentNullException("key");
      if (value == null) throw new ArgumentNullException("value");
      
      Key = key;
      Value = value;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string key, [NotNull] out string value)
    {
      key = Key;
      value = Value;
    }
    //statics
    
    public static CtxReadDelegate<ProcessEnvironmentVariable> Read = (ctx, reader) => 
    {
      var key = reader.ReadString();
      var value = reader.ReadString();
      var _result = new ProcessEnvironmentVariable(key, value);
      return _result;
    };
    
    public static CtxWriteDelegate<ProcessEnvironmentVariable> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Key);
      writer.Write(value.Value);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((ProcessEnvironmentVariable) obj);
    }
    public bool Equals(ProcessEnvironmentVariable other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Key == other.Key && Value == other.Value;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Key.GetHashCode();
        hash = hash * 31 + Value.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("ProcessEnvironmentVariable (");
      using (printer.IndentCookie()) {
        printer.Print("key = "); Key.PrintEx(printer); printer.Println();
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:22</p>
  /// </summary>
  public sealed class ProcessInfo : IPrintable, IEquatable<ProcessInfo>
  {
    //fields
    //public fields
    [NotNull] public string ProcessName {get; private set;}
    [CanBeNull] public string Filename {get; private set;}
    [CanBeNull] public string StartTime {get; private set;}
    [CanBeNull] public string CommandLine {get; private set;}
    [CanBeNull] public string OperatingSystem {get; private set;}
    [CanBeNull] public string ProcessArchitecture {get; private set;}
    [NotNull] public ProcessEnvironmentVariable[] EnvironmentVariables {get; private set;}
    
    //private fields
    //primary constructor
    public ProcessInfo(
      [NotNull] string processName,
      [CanBeNull] string filename,
      [CanBeNull] string startTime,
      [CanBeNull] string commandLine,
      [CanBeNull] string operatingSystem,
      [CanBeNull] string processArchitecture,
      [NotNull] ProcessEnvironmentVariable[] environmentVariables
    )
    {
      if (processName == null) throw new ArgumentNullException("processName");
      if (environmentVariables == null) throw new ArgumentNullException("environmentVariables");
      
      ProcessName = processName;
      Filename = filename;
      StartTime = startTime;
      CommandLine = commandLine;
      OperatingSystem = operatingSystem;
      ProcessArchitecture = processArchitecture;
      EnvironmentVariables = environmentVariables;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string processName, [CanBeNull] out string filename, [CanBeNull] out string startTime, [CanBeNull] out string commandLine, [CanBeNull] out string operatingSystem, [CanBeNull] out string processArchitecture, [NotNull] out ProcessEnvironmentVariable[] environmentVariables)
    {
      processName = ProcessName;
      filename = Filename;
      startTime = StartTime;
      commandLine = CommandLine;
      operatingSystem = OperatingSystem;
      processArchitecture = ProcessArchitecture;
      environmentVariables = EnvironmentVariables;
    }
    //statics
    
    public static CtxReadDelegate<ProcessInfo> Read = (ctx, reader) => 
    {
      var processName = reader.ReadString();
      var filename = ReadStringNullable(ctx, reader);
      var startTime = ReadStringNullable(ctx, reader);
      var commandLine = ReadStringNullable(ctx, reader);
      var operatingSystem = ReadStringNullable(ctx, reader);
      var processArchitecture = ReadStringNullable(ctx, reader);
      var environmentVariables = ReadProcessEnvironmentVariableArray(ctx, reader);
      var _result = new ProcessInfo(processName, filename, startTime, commandLine, operatingSystem, processArchitecture, environmentVariables);
      return _result;
    };
    public static CtxReadDelegate<string> ReadStringNullable = JetBrains.Rd.Impl.Serializers.ReadString.NullableClass();
    public static CtxReadDelegate<ProcessEnvironmentVariable[]> ReadProcessEnvironmentVariableArray = ProcessEnvironmentVariable.Read.Array();
    
    public static CtxWriteDelegate<ProcessInfo> Write = (ctx, writer, value) => 
    {
      writer.Write(value.ProcessName);
      WriteStringNullable(ctx, writer, value.Filename);
      WriteStringNullable(ctx, writer, value.StartTime);
      WriteStringNullable(ctx, writer, value.CommandLine);
      WriteStringNullable(ctx, writer, value.OperatingSystem);
      WriteStringNullable(ctx, writer, value.ProcessArchitecture);
      WriteProcessEnvironmentVariableArray(ctx, writer, value.EnvironmentVariables);
    };
    public static  CtxWriteDelegate<string> WriteStringNullable = JetBrains.Rd.Impl.Serializers.WriteString.NullableClass();
    public static  CtxWriteDelegate<ProcessEnvironmentVariable[]> WriteProcessEnvironmentVariableArray = ProcessEnvironmentVariable.Write.Array();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((ProcessInfo) obj);
    }
    public bool Equals(ProcessInfo other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return ProcessName == other.ProcessName && Equals(Filename, other.Filename) && Equals(StartTime, other.StartTime) && Equals(CommandLine, other.CommandLine) && Equals(OperatingSystem, other.OperatingSystem) && Equals(ProcessArchitecture, other.ProcessArchitecture) && EnvironmentVariables.SequenceEqual(other.EnvironmentVariables);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + ProcessName.GetHashCode();
        hash = hash * 31 + (Filename != null ? Filename.GetHashCode() : 0);
        hash = hash * 31 + (StartTime != null ? StartTime.GetHashCode() : 0);
        hash = hash * 31 + (CommandLine != null ? CommandLine.GetHashCode() : 0);
        hash = hash * 31 + (OperatingSystem != null ? OperatingSystem.GetHashCode() : 0);
        hash = hash * 31 + (ProcessArchitecture != null ? ProcessArchitecture.GetHashCode() : 0);
        hash = hash * 31 + EnvironmentVariables.ContentHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("ProcessInfo (");
      using (printer.IndentCookie()) {
        printer.Print("processName = "); ProcessName.PrintEx(printer); printer.Println();
        printer.Print("filename = "); Filename.PrintEx(printer); printer.Println();
        printer.Print("startTime = "); StartTime.PrintEx(printer); printer.Println();
        printer.Print("commandLine = "); CommandLine.PrintEx(printer); printer.Println();
        printer.Print("operatingSystem = "); OperatingSystem.PrintEx(printer); printer.Println();
        printer.Print("processArchitecture = "); ProcessArchitecture.PrintEx(printer); printer.Println();
        printer.Print("environmentVariables = "); EnvironmentVariables.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:32</p>
  /// </summary>
  public sealed class ProcessList : RdBindableBase
  {
    //fields
    //public fields
    [NotNull] public IViewableMap<int, ProcessInfo> Items => _Items;
    
    //private fields
    [NotNull] private readonly RdMap<int, ProcessInfo> _Items;
    
    //primary constructor
    private ProcessList(
      [NotNull] RdMap<int, ProcessInfo> items
    )
    {
      if (items == null) throw new ArgumentNullException("items");
      
      _Items = items;
      _Items.OptimizeNested = true;
      _Items.Async = true;
      BindableChildren.Add(new KeyValuePair<string, object>("items", _Items));
    }
    //secondary constructor
    public ProcessList (
    ) : this (
      new RdMap<int, ProcessInfo>(JetBrains.Rd.Impl.Serializers.ReadInt, JetBrains.Rd.Impl.Serializers.WriteInt, ProcessInfo.Read, ProcessInfo.Write)
    ) {}
    //deconstruct trait
    //statics
    
    public static CtxReadDelegate<ProcessList> Read = (ctx, reader) => 
    {
      var _id = RdId.Read(reader);
      var items = RdMap<int, ProcessInfo>.Read(ctx, reader, JetBrains.Rd.Impl.Serializers.ReadInt, JetBrains.Rd.Impl.Serializers.WriteInt, ProcessInfo.Read, ProcessInfo.Write);
      var _result = new ProcessList(items).WithId(_id);
      return _result;
    };
    
    public static CtxWriteDelegate<ProcessList> Write = (ctx, writer, value) => 
    {
      value.RdId.Write(writer);
      RdMap<int, ProcessInfo>.Write(ctx, writer, value._Items);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("ProcessList (");
      using (printer.IndentCookie()) {
        printer.Print("items = "); _Items.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:36</p>
  /// </summary>
  public abstract class Session : RdBindableBase
  {
    //fields
    //public fields
    [NotNull] public IViewableProperty<bool> Active => _Active;
    [NotNull] public IViewableProperty<int?> Duration => _Duration;
    
    //private fields
    [NotNull] protected readonly RdProperty<bool> _Active;
    [NotNull] protected readonly RdProperty<int?> _Duration;
    
    //primary constructor
    protected Session(
      [NotNull] RdProperty<bool> active,
      [NotNull] RdProperty<int?> duration
    )
    {
      if (active == null) throw new ArgumentNullException("active");
      if (duration == null) throw new ArgumentNullException("duration");
      
      _Active = active;
      _Duration = duration;
      _Active.OptimizeNested = true;
      _Duration.OptimizeNested = true;
      _Duration.ValueCanBeNull = true;
      BindableChildren.Add(new KeyValuePair<string, object>("active", _Active));
      BindableChildren.Add(new KeyValuePair<string, object>("duration", _Duration));
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static CtxReadDelegate<Session> Read = Polymorphic<Session>.ReadAbstract(Session_Unknown.Read);
    
    public static CtxWriteDelegate<Session> Write = Polymorphic<Session>.Write;
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    //toString
  }
  
  
  public sealed class Session_Unknown : Session
  {
    //fields
    //public fields
    
    //private fields
    //primary constructor
    private Session_Unknown(
      [NotNull] RdProperty<bool> active,
      [NotNull] RdProperty<int?> duration
    ) : base (
      active,
      duration
     ) 
    {
    }
    //secondary constructor
    public Session_Unknown (
    ) : this (
      new RdProperty<bool>(JetBrains.Rd.Impl.Serializers.ReadBool, JetBrains.Rd.Impl.Serializers.WriteBool),
      new RdProperty<int?>(ReadIntNullable, WriteIntNullable)
    ) {}
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<Session_Unknown> Read = (ctx, reader) => 
    {
      var _id = RdId.Read(reader);
      var active = RdProperty<bool>.Read(ctx, reader, JetBrains.Rd.Impl.Serializers.ReadBool, JetBrains.Rd.Impl.Serializers.WriteBool);
      var duration = RdProperty<int?>.Read(ctx, reader, ReadIntNullable, WriteIntNullable);
      var _result = new Session_Unknown(active, duration).WithId(_id);
      return _result;
    };
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static new CtxWriteDelegate<Session_Unknown> Write = (ctx, writer, value) => 
    {
      value.RdId.Write(writer);
      RdProperty<bool>.Write(ctx, writer, value._Active);
      RdProperty<int?>.Write(ctx, writer, value._Duration);
    };
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("Session_Unknown (");
      using (printer.IndentCookie()) {
        printer.Print("active = "); _Active.PrintEx(printer); printer.Println();
        printer.Print("duration = "); _Duration.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:98</p>
  /// </summary>
  public sealed class Trace : IPrintable, IEquatable<Trace>
  {
    //fields
    //public fields
    [NotNull] public string EventName {get; private set;}
    public PredefinedProvider Provider {get; private set;}
    public DateTime TimeStamp {get; private set;}
    [NotNull] public string Content {get; private set;}
    
    //private fields
    //primary constructor
    public Trace(
      [NotNull] string eventName,
      PredefinedProvider provider,
      DateTime timeStamp,
      [NotNull] string content
    )
    {
      if (eventName == null) throw new ArgumentNullException("eventName");
      if (content == null) throw new ArgumentNullException("content");
      
      EventName = eventName;
      Provider = provider;
      TimeStamp = timeStamp;
      Content = content;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string eventName, out PredefinedProvider provider, out DateTime timeStamp, [NotNull] out string content)
    {
      eventName = EventName;
      provider = Provider;
      timeStamp = TimeStamp;
      content = Content;
    }
    //statics
    
    public static CtxReadDelegate<Trace> Read = (ctx, reader) => 
    {
      var eventName = reader.ReadString();
      var provider = (PredefinedProvider)reader.ReadInt();
      var timeStamp = reader.ReadDateTime();
      var content = reader.ReadString();
      var _result = new Trace(eventName, provider, timeStamp, content);
      return _result;
    };
    
    public static CtxWriteDelegate<Trace> Write = (ctx, writer, value) => 
    {
      writer.Write(value.EventName);
      writer.Write((int)value.Provider);
      writer.Write(value.TimeStamp);
      writer.Write(value.Content);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((Trace) obj);
    }
    public bool Equals(Trace other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return EventName == other.EventName && Provider == other.Provider && TimeStamp == other.TimeStamp && Content == other.Content;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + EventName.GetHashCode();
        hash = hash * 31 + (int) Provider;
        hash = hash * 31 + TimeStamp.GetHashCode();
        hash = hash * 31 + Content.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("Trace (");
      using (printer.IndentCookie()) {
        printer.Print("eventName = "); EventName.PrintEx(printer); printer.Println();
        printer.Print("provider = "); Provider.PrintEx(printer); printer.Println();
        printer.Print("timeStamp = "); TimeStamp.PrintEx(printer); printer.Println();
        printer.Print("content = "); Content.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:200</p>
  /// </summary>
  public sealed class TraceCollectionResult : IPrintable, IEquatable<TraceCollectionResult>
  {
    //fields
    //public fields
    [NotNull] public string FilePath {get; private set;}
    
    //private fields
    //primary constructor
    public TraceCollectionResult(
      [NotNull] string filePath
    )
    {
      if (filePath == null) throw new ArgumentNullException("filePath");
      
      FilePath = filePath;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string filePath)
    {
      filePath = FilePath;
    }
    //statics
    
    public static CtxReadDelegate<TraceCollectionResult> Read = (ctx, reader) => 
    {
      var filePath = reader.ReadString();
      var _result = new TraceCollectionResult(filePath);
      return _result;
    };
    
    public static CtxWriteDelegate<TraceCollectionResult> Write = (ctx, writer, value) => 
    {
      writer.Write(value.FilePath);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((TraceCollectionResult) obj);
    }
    public bool Equals(TraceCollectionResult other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return FilePath == other.FilePath;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + FilePath.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("TraceCollectionResult (");
      using (printer.IndentCookie()) {
        printer.Print("filePath = "); FilePath.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:54</p>
  /// </summary>
  public sealed class TraceSession : Session
  {
    //fields
    //public fields
    [NotNull] public ISignal<Trace> TraceReceived => _TraceReceived;
    [NotNull] public List<PredefinedProvider> PredefinedProviders {get; private set;}
    
    //private fields
    [NotNull] private readonly RdSignal<Trace> _TraceReceived;
    
    //primary constructor
    private TraceSession(
      [NotNull] RdSignal<Trace> traceReceived,
      [NotNull] List<PredefinedProvider> predefinedProviders,
      [NotNull] RdProperty<bool> active,
      [NotNull] RdProperty<int?> duration
    ) : base (
      active,
      duration
     ) 
    {
      if (traceReceived == null) throw new ArgumentNullException("traceReceived");
      if (predefinedProviders == null) throw new ArgumentNullException("predefinedProviders");
      
      _TraceReceived = traceReceived;
      PredefinedProviders = predefinedProviders;
      _TraceReceived.Async = true;
      BindableChildren.Add(new KeyValuePair<string, object>("traceReceived", _TraceReceived));
    }
    //secondary constructor
    public TraceSession (
      [NotNull] List<PredefinedProvider> predefinedProviders
    ) : this (
      new RdSignal<Trace>(Trace.Read, Trace.Write),
      predefinedProviders,
      new RdProperty<bool>(JetBrains.Rd.Impl.Serializers.ReadBool, JetBrains.Rd.Impl.Serializers.WriteBool),
      new RdProperty<int?>(ReadIntNullable, WriteIntNullable)
    ) {}
    //deconstruct trait
    //statics
    
    public static new CtxReadDelegate<TraceSession> Read = (ctx, reader) => 
    {
      var _id = RdId.Read(reader);
      var active = RdProperty<bool>.Read(ctx, reader, JetBrains.Rd.Impl.Serializers.ReadBool, JetBrains.Rd.Impl.Serializers.WriteBool);
      var duration = RdProperty<int?>.Read(ctx, reader, ReadIntNullable, WriteIntNullable);
      var traceReceived = RdSignal<Trace>.Read(ctx, reader, Trace.Read, Trace.Write);
      var predefinedProviders = ReadPredefinedProviderList(ctx, reader);
      var _result = new TraceSession(traceReceived, predefinedProviders, active, duration).WithId(_id);
      return _result;
    };
    public static CtxReadDelegate<List<PredefinedProvider>> ReadPredefinedProviderList = new CtxReadDelegate<PredefinedProvider>(JetBrains.Rd.Impl.Serializers.ReadEnum<PredefinedProvider>).List();
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static new CtxWriteDelegate<TraceSession> Write = (ctx, writer, value) => 
    {
      value.RdId.Write(writer);
      RdProperty<bool>.Write(ctx, writer, value._Active);
      RdProperty<int?>.Write(ctx, writer, value._Duration);
      RdSignal<Trace>.Write(ctx, writer, value._TraceReceived);
      WritePredefinedProviderList(ctx, writer, value.PredefinedProviders);
    };
    public static  CtxWriteDelegate<List<PredefinedProvider>> WritePredefinedProviderList = new CtxWriteDelegate<PredefinedProvider>(JetBrains.Rd.Impl.Serializers.WriteEnum<PredefinedProvider>).List();
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("TraceSession (");
      using (printer.IndentCookie()) {
        printer.Print("traceReceived = "); _TraceReceived.PrintEx(printer); printer.Println();
        printer.Print("predefinedProviders = "); PredefinedProviders.PrintEx(printer); printer.Println();
        printer.Print("active = "); _Active.PrintEx(printer); printer.Println();
        printer.Print("duration = "); _Duration.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:192</p>
  /// </summary>
  public enum TracingProfile {
    None,
    CpuSampling,
    GcVerbose,
    GcCollect
  }
}
