//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.10.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Linq;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using JetBrains.Annotations;

using JetBrains.Core;
using JetBrains.Diagnostics;
using JetBrains.Collections;
using JetBrains.Collections.Viewable;
using JetBrains.Lifetimes;
using JetBrains.Serialization;
using JetBrains.Rd;
using JetBrains.Rd.Base;
using JetBrains.Rd.Impl;
using JetBrains.Rd.Tasks;
using JetBrains.Rd.Util;
using JetBrains.Rd.Text;


// ReSharper disable RedundantEmptyObjectCreationArgumentList
// ReSharper disable InconsistentNaming
// ReSharper disable RedundantOverflowCheckingContext


namespace DiagnosticsClientPlugin.Generated
{
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:10</p>
  /// </summary>
  public class DiagnosticsHostModel : RdExtBase
  {
    //fields
    //public fields
    [NotNull] public DiagnosticsClientPlugin.Generated.ProcessList ProcessList {get; private set;}
    [NotNull] public IViewableList<int> GcEventsCollectionSessions => _GcEventsCollectionSessions;
    [NotNull] public IViewableMap<int, GcEventsMonitoringSession> GcEventsMonitoringSessions => _GcEventsMonitoringSessions;
    [NotNull] public IViewableList<int> TraceCollectionSessions => _TraceCollectionSessions;
    [NotNull] public IViewableMap<int, CounterCollectionSession> CounterCollectionSessions => _CounterCollectionSessions;
    [NotNull] public IViewableMap<int, CountersMonitoringSession> CounterMonitoringSessions => _CounterMonitoringSessions;
    [NotNull] public IRdEndpoint<CollectDumpCommand, DumpCollectionResult> CollectDump => _CollectDump;
    [NotNull] public IRdEndpoint<CollectGcEventsCommand, Unit> CollectGcEvents => _CollectGcEvents;
    [NotNull] public IRdEndpoint<MonitorGcEventsCommand, Unit> MonitorGcEvents => _MonitorGcEvents;
    [NotNull] public IRdEndpoint<TriggerGcCommand, Unit> TriggerGc => _TriggerGc;
    [NotNull] public IRdEndpoint<CollectTracesCommand, Unit> CollectTraces => _CollectTraces;
    [NotNull] public IRdEndpoint<CollectStackTraceCommand, string> CollectStackTrace => _CollectStackTrace;
    
    //private fields
    [NotNull] private readonly RdList<int> _GcEventsCollectionSessions;
    [NotNull] private readonly RdMap<int, GcEventsMonitoringSession> _GcEventsMonitoringSessions;
    [NotNull] private readonly RdList<int> _TraceCollectionSessions;
    [NotNull] private readonly RdMap<int, CounterCollectionSession> _CounterCollectionSessions;
    [NotNull] private readonly RdMap<int, CountersMonitoringSession> _CounterMonitoringSessions;
    [NotNull] private readonly RdCall<CollectDumpCommand, DumpCollectionResult> _CollectDump;
    [NotNull] private readonly RdCall<CollectGcEventsCommand, Unit> _CollectGcEvents;
    [NotNull] private readonly RdCall<MonitorGcEventsCommand, Unit> _MonitorGcEvents;
    [NotNull] private readonly RdCall<TriggerGcCommand, Unit> _TriggerGc;
    [NotNull] private readonly RdCall<CollectTracesCommand, Unit> _CollectTraces;
    [NotNull] private readonly RdCall<CollectStackTraceCommand, string> _CollectStackTrace;
    
    //primary constructor
    private DiagnosticsHostModel(
      [NotNull] DiagnosticsClientPlugin.Generated.ProcessList processList,
      [NotNull] RdList<int> gcEventsCollectionSessions,
      [NotNull] RdMap<int, GcEventsMonitoringSession> gcEventsMonitoringSessions,
      [NotNull] RdList<int> traceCollectionSessions,
      [NotNull] RdMap<int, CounterCollectionSession> counterCollectionSessions,
      [NotNull] RdMap<int, CountersMonitoringSession> counterMonitoringSessions,
      [NotNull] RdCall<CollectDumpCommand, DumpCollectionResult> collectDump,
      [NotNull] RdCall<CollectGcEventsCommand, Unit> collectGcEvents,
      [NotNull] RdCall<MonitorGcEventsCommand, Unit> monitorGcEvents,
      [NotNull] RdCall<TriggerGcCommand, Unit> triggerGc,
      [NotNull] RdCall<CollectTracesCommand, Unit> collectTraces,
      [NotNull] RdCall<CollectStackTraceCommand, string> collectStackTrace
    )
    {
      if (processList == null) throw new ArgumentNullException("processList");
      if (gcEventsCollectionSessions == null) throw new ArgumentNullException("gcEventsCollectionSessions");
      if (gcEventsMonitoringSessions == null) throw new ArgumentNullException("gcEventsMonitoringSessions");
      if (traceCollectionSessions == null) throw new ArgumentNullException("traceCollectionSessions");
      if (counterCollectionSessions == null) throw new ArgumentNullException("counterCollectionSessions");
      if (counterMonitoringSessions == null) throw new ArgumentNullException("counterMonitoringSessions");
      if (collectDump == null) throw new ArgumentNullException("collectDump");
      if (collectGcEvents == null) throw new ArgumentNullException("collectGcEvents");
      if (monitorGcEvents == null) throw new ArgumentNullException("monitorGcEvents");
      if (triggerGc == null) throw new ArgumentNullException("triggerGc");
      if (collectTraces == null) throw new ArgumentNullException("collectTraces");
      if (collectStackTrace == null) throw new ArgumentNullException("collectStackTrace");
      
      ProcessList = processList;
      _GcEventsCollectionSessions = gcEventsCollectionSessions;
      _GcEventsMonitoringSessions = gcEventsMonitoringSessions;
      _TraceCollectionSessions = traceCollectionSessions;
      _CounterCollectionSessions = counterCollectionSessions;
      _CounterMonitoringSessions = counterMonitoringSessions;
      _CollectDump = collectDump;
      _CollectGcEvents = collectGcEvents;
      _MonitorGcEvents = monitorGcEvents;
      _TriggerGc = triggerGc;
      _CollectTraces = collectTraces;
      _CollectStackTrace = collectStackTrace;
      _GcEventsCollectionSessions.OptimizeNested = true;
      _TraceCollectionSessions.OptimizeNested = true;
      _GcEventsCollectionSessions.Async = true;
      _GcEventsMonitoringSessions.Async = true;
      _TraceCollectionSessions.Async = true;
      BindableChildren.Add(new KeyValuePair<string, object>("processList", ProcessList));
      BindableChildren.Add(new KeyValuePair<string, object>("gcEventsCollectionSessions", _GcEventsCollectionSessions));
      BindableChildren.Add(new KeyValuePair<string, object>("gcEventsMonitoringSessions", _GcEventsMonitoringSessions));
      BindableChildren.Add(new KeyValuePair<string, object>("traceCollectionSessions", _TraceCollectionSessions));
      BindableChildren.Add(new KeyValuePair<string, object>("counterCollectionSessions", _CounterCollectionSessions));
      BindableChildren.Add(new KeyValuePair<string, object>("counterMonitoringSessions", _CounterMonitoringSessions));
      BindableChildren.Add(new KeyValuePair<string, object>("collectDump", _CollectDump));
      BindableChildren.Add(new KeyValuePair<string, object>("collectGcEvents", _CollectGcEvents));
      BindableChildren.Add(new KeyValuePair<string, object>("monitorGcEvents", _MonitorGcEvents));
      BindableChildren.Add(new KeyValuePair<string, object>("triggerGc", _TriggerGc));
      BindableChildren.Add(new KeyValuePair<string, object>("collectTraces", _CollectTraces));
      BindableChildren.Add(new KeyValuePair<string, object>("collectStackTrace", _CollectStackTrace));
    }
    //secondary constructor
    internal DiagnosticsHostModel (
    ) : this (
      new DiagnosticsClientPlugin.Generated.ProcessList(),
      new RdList<int>(JetBrains.Rd.Impl.Serializers.ReadInt, JetBrains.Rd.Impl.Serializers.WriteInt),
      new RdMap<int, GcEventsMonitoringSession>(JetBrains.Rd.Impl.Serializers.ReadInt, JetBrains.Rd.Impl.Serializers.WriteInt, GcEventsMonitoringSession.Read, GcEventsMonitoringSession.Write),
      new RdList<int>(JetBrains.Rd.Impl.Serializers.ReadInt, JetBrains.Rd.Impl.Serializers.WriteInt),
      new RdMap<int, CounterCollectionSession>(JetBrains.Rd.Impl.Serializers.ReadInt, JetBrains.Rd.Impl.Serializers.WriteInt, CounterCollectionSession.Read, CounterCollectionSession.Write),
      new RdMap<int, CountersMonitoringSession>(JetBrains.Rd.Impl.Serializers.ReadInt, JetBrains.Rd.Impl.Serializers.WriteInt, CountersMonitoringSession.Read, CountersMonitoringSession.Write),
      new RdCall<CollectDumpCommand, DumpCollectionResult>(CollectDumpCommand.Read, CollectDumpCommand.Write, DumpCollectionResult.Read, DumpCollectionResult.Write),
      new RdCall<CollectGcEventsCommand, Unit>(CollectGcEventsCommand.Read, CollectGcEventsCommand.Write, JetBrains.Rd.Impl.Serializers.ReadVoid, JetBrains.Rd.Impl.Serializers.WriteVoid),
      new RdCall<MonitorGcEventsCommand, Unit>(MonitorGcEventsCommand.Read, MonitorGcEventsCommand.Write, JetBrains.Rd.Impl.Serializers.ReadVoid, JetBrains.Rd.Impl.Serializers.WriteVoid),
      new RdCall<TriggerGcCommand, Unit>(TriggerGcCommand.Read, TriggerGcCommand.Write, JetBrains.Rd.Impl.Serializers.ReadVoid, JetBrains.Rd.Impl.Serializers.WriteVoid),
      new RdCall<CollectTracesCommand, Unit>(CollectTracesCommand.Read, CollectTracesCommand.Write, JetBrains.Rd.Impl.Serializers.ReadVoid, JetBrains.Rd.Impl.Serializers.WriteVoid),
      new RdCall<CollectStackTraceCommand, string>(CollectStackTraceCommand.Read, CollectStackTraceCommand.Write, JetBrains.Rd.Impl.Serializers.ReadString, JetBrains.Rd.Impl.Serializers.WriteString)
    ) {}
    //deconstruct trait
    //statics
    
    
    
    protected override long SerializationHash => 6355498676304255287L;
    
    protected override Action<ISerializers> Register => RegisterDeclaredTypesSerializers;
    public static void RegisterDeclaredTypesSerializers(ISerializers serializers)
    {
      
      serializers.RegisterToplevelOnce(typeof(JetBrains.Rider.Model.IdeRoot), JetBrains.Rider.Model.IdeRoot.RegisterDeclaredTypesSerializers);
    }
    
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("DiagnosticsHostModel (");
      using (printer.IndentCookie()) {
        printer.Print("processList = "); ProcessList.PrintEx(printer); printer.Println();
        printer.Print("gcEventsCollectionSessions = "); _GcEventsCollectionSessions.PrintEx(printer); printer.Println();
        printer.Print("gcEventsMonitoringSessions = "); _GcEventsMonitoringSessions.PrintEx(printer); printer.Println();
        printer.Print("traceCollectionSessions = "); _TraceCollectionSessions.PrintEx(printer); printer.Println();
        printer.Print("counterCollectionSessions = "); _CounterCollectionSessions.PrintEx(printer); printer.Println();
        printer.Print("counterMonitoringSessions = "); _CounterMonitoringSessions.PrintEx(printer); printer.Println();
        printer.Print("collectDump = "); _CollectDump.PrintEx(printer); printer.Println();
        printer.Print("collectGcEvents = "); _CollectGcEvents.PrintEx(printer); printer.Println();
        printer.Print("monitorGcEvents = "); _MonitorGcEvents.PrintEx(printer); printer.Println();
        printer.Print("triggerGc = "); _TriggerGc.PrintEx(printer); printer.Println();
        printer.Print("collectTraces = "); _CollectTraces.PrintEx(printer); printer.Println();
        printer.Print("collectStackTrace = "); _CollectStackTrace.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  public static class SolutionDiagnosticsHostModelEx
   {
    public static DiagnosticsHostModel GetDiagnosticsHostModel(this JetBrains.Rider.Model.Solution solution)
    {
      return solution.GetOrCreateExtension("diagnosticsHostModel", () => new DiagnosticsHostModel());
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:98</p>
  /// </summary>
  public sealed class CollectDumpCommand : IPrintable, IEquatable<CollectDumpCommand>
  {
    //fields
    //public fields
    public int Pid {get; private set;}
    public DumpType Type {get; private set;}
    [NotNull] public string OutFolder {get; private set;}
    [NotNull] public string Filename {get; private set;}
    public bool Diag {get; private set;}
    
    //private fields
    //primary constructor
    public CollectDumpCommand(
      int pid,
      DumpType type,
      [NotNull] string outFolder,
      [NotNull] string filename,
      bool diag
    )
    {
      if (outFolder == null) throw new ArgumentNullException("outFolder");
      if (filename == null) throw new ArgumentNullException("filename");
      
      Pid = pid;
      Type = type;
      OutFolder = outFolder;
      Filename = filename;
      Diag = diag;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct(out int pid, out DumpType type, [NotNull] out string outFolder, [NotNull] out string filename, out bool diag)
    {
      pid = Pid;
      type = Type;
      outFolder = OutFolder;
      filename = Filename;
      diag = Diag;
    }
    //statics
    
    public static CtxReadDelegate<CollectDumpCommand> Read = (ctx, reader) => 
    {
      var pid = reader.ReadInt();
      var type = (DumpType)reader.ReadInt();
      var outFolder = reader.ReadString();
      var filename = reader.ReadString();
      var diag = reader.ReadBool();
      var _result = new CollectDumpCommand(pid, type, outFolder, filename, diag);
      return _result;
    };
    
    public static CtxWriteDelegate<CollectDumpCommand> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Pid);
      writer.Write((int)value.Type);
      writer.Write(value.OutFolder);
      writer.Write(value.Filename);
      writer.Write(value.Diag);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((CollectDumpCommand) obj);
    }
    public bool Equals(CollectDumpCommand other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Pid == other.Pid && Type == other.Type && OutFolder == other.OutFolder && Filename == other.Filename && Diag == other.Diag;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Pid.GetHashCode();
        hash = hash * 31 + (int) Type;
        hash = hash * 31 + OutFolder.GetHashCode();
        hash = hash * 31 + Filename.GetHashCode();
        hash = hash * 31 + Diag.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("CollectDumpCommand (");
      using (printer.IndentCookie()) {
        printer.Print("pid = "); Pid.PrintEx(printer); printer.Println();
        printer.Print("type = "); Type.PrintEx(printer); printer.Println();
        printer.Print("outFolder = "); OutFolder.PrintEx(printer); printer.Println();
        printer.Print("filename = "); Filename.PrintEx(printer); printer.Println();
        printer.Print("diag = "); Diag.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:115</p>
  /// </summary>
  public sealed class CollectGcEventsCommand : IPrintable, IEquatable<CollectGcEventsCommand>
  {
    //fields
    //public fields
    public int Pid {get; private set;}
    [NotNull] public string FilePath {get; private set;}
    [CanBeNull] public int? Duration {get; private set;}
    
    //private fields
    //primary constructor
    public CollectGcEventsCommand(
      int pid,
      [NotNull] string filePath,
      [CanBeNull] int? duration
    )
    {
      if (filePath == null) throw new ArgumentNullException("filePath");
      
      Pid = pid;
      FilePath = filePath;
      Duration = duration;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct(out int pid, [NotNull] out string filePath, [CanBeNull] out int? duration)
    {
      pid = Pid;
      filePath = FilePath;
      duration = Duration;
    }
    //statics
    
    public static CtxReadDelegate<CollectGcEventsCommand> Read = (ctx, reader) => 
    {
      var pid = reader.ReadInt();
      var filePath = reader.ReadString();
      var duration = ReadIntNullable(ctx, reader);
      var _result = new CollectGcEventsCommand(pid, filePath, duration);
      return _result;
    };
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static CtxWriteDelegate<CollectGcEventsCommand> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Pid);
      writer.Write(value.FilePath);
      WriteIntNullable(ctx, writer, value.Duration);
    };
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((CollectGcEventsCommand) obj);
    }
    public bool Equals(CollectGcEventsCommand other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Pid == other.Pid && FilePath == other.FilePath && Equals(Duration, other.Duration);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Pid.GetHashCode();
        hash = hash * 31 + FilePath.GetHashCode();
        hash = hash * 31 + (Duration != null ? Duration.GetHashCode() : 0);
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("CollectGcEventsCommand (");
      using (printer.IndentCookie()) {
        printer.Print("pid = "); Pid.PrintEx(printer); printer.Println();
        printer.Print("filePath = "); FilePath.PrintEx(printer); printer.Println();
        printer.Print("duration = "); Duration.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:153</p>
  /// </summary>
  public sealed class CollectStackTraceCommand : IPrintable, IEquatable<CollectStackTraceCommand>
  {
    //fields
    //public fields
    public int Pid {get; private set;}
    
    //private fields
    //primary constructor
    public CollectStackTraceCommand(
      int pid
    )
    {
      Pid = pid;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct(out int pid)
    {
      pid = Pid;
    }
    //statics
    
    public static CtxReadDelegate<CollectStackTraceCommand> Read = (ctx, reader) => 
    {
      var pid = reader.ReadInt();
      var _result = new CollectStackTraceCommand(pid);
      return _result;
    };
    
    public static CtxWriteDelegate<CollectStackTraceCommand> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Pid);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((CollectStackTraceCommand) obj);
    }
    public bool Equals(CollectStackTraceCommand other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Pid == other.Pid;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Pid.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("CollectStackTraceCommand (");
      using (printer.IndentCookie()) {
        printer.Print("pid = "); Pid.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:136</p>
  /// </summary>
  public sealed class CollectTracesCommand : IPrintable, IEquatable<CollectTracesCommand>
  {
    //fields
    //public fields
    public int Pid {get; private set;}
    [NotNull] public string FilePath {get; private set;}
    public TracingProfile Profile {get; private set;}
    [NotNull] public string Providers {get; private set;}
    [CanBeNull] public int? Duration {get; private set;}
    
    //private fields
    //primary constructor
    public CollectTracesCommand(
      int pid,
      [NotNull] string filePath,
      TracingProfile profile,
      [NotNull] string providers,
      [CanBeNull] int? duration
    )
    {
      if (filePath == null) throw new ArgumentNullException("filePath");
      if (providers == null) throw new ArgumentNullException("providers");
      
      Pid = pid;
      FilePath = filePath;
      Profile = profile;
      Providers = providers;
      Duration = duration;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct(out int pid, [NotNull] out string filePath, out TracingProfile profile, [NotNull] out string providers, [CanBeNull] out int? duration)
    {
      pid = Pid;
      filePath = FilePath;
      profile = Profile;
      providers = Providers;
      duration = Duration;
    }
    //statics
    
    public static CtxReadDelegate<CollectTracesCommand> Read = (ctx, reader) => 
    {
      var pid = reader.ReadInt();
      var filePath = reader.ReadString();
      var profile = (TracingProfile)reader.ReadInt();
      var providers = reader.ReadString();
      var duration = ReadIntNullable(ctx, reader);
      var _result = new CollectTracesCommand(pid, filePath, profile, providers, duration);
      return _result;
    };
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static CtxWriteDelegate<CollectTracesCommand> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Pid);
      writer.Write(value.FilePath);
      writer.Write((int)value.Profile);
      writer.Write(value.Providers);
      WriteIntNullable(ctx, writer, value.Duration);
    };
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((CollectTracesCommand) obj);
    }
    public bool Equals(CollectTracesCommand other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Pid == other.Pid && FilePath == other.FilePath && Profile == other.Profile && Providers == other.Providers && Equals(Duration, other.Duration);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Pid.GetHashCode();
        hash = hash * 31 + FilePath.GetHashCode();
        hash = hash * 31 + (int) Profile;
        hash = hash * 31 + Providers.GetHashCode();
        hash = hash * 31 + (Duration != null ? Duration.GetHashCode() : 0);
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("CollectTracesCommand (");
      using (printer.IndentCookie()) {
        printer.Print("pid = "); Pid.PrintEx(printer); printer.Println();
        printer.Print("filePath = "); FilePath.PrintEx(printer); printer.Println();
        printer.Print("profile = "); Profile.PrintEx(printer); printer.Println();
        printer.Print("providers = "); Providers.PrintEx(printer); printer.Println();
        printer.Print("duration = "); Duration.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:34</p>
  /// </summary>
  public sealed class Counter : IPrintable, IEquatable<Counter>
  {
    //fields
    //public fields
    [NotNull] public string Name {get; private set;}
    [CanBeNull] public string Tags {get; private set;}
    public double Value {get; private set;}
    
    //private fields
    //primary constructor
    public Counter(
      [NotNull] string name,
      [CanBeNull] string tags,
      double value
    )
    {
      if (name == null) throw new ArgumentNullException("name");
      
      Name = name;
      Tags = tags;
      Value = value;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string name, [CanBeNull] out string tags, out double value)
    {
      name = Name;
      tags = Tags;
      value = Value;
    }
    //statics
    
    public static CtxReadDelegate<Counter> Read = (ctx, reader) => 
    {
      var name = reader.ReadString();
      var tags = ReadStringNullable(ctx, reader);
      var value = reader.ReadDouble();
      var _result = new Counter(name, tags, value);
      return _result;
    };
    public static CtxReadDelegate<string> ReadStringNullable = JetBrains.Rd.Impl.Serializers.ReadString.NullableClass();
    
    public static CtxWriteDelegate<Counter> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Name);
      WriteStringNullable(ctx, writer, value.Tags);
      writer.Write(value.Value);
    };
    public static  CtxWriteDelegate<string> WriteStringNullable = JetBrains.Rd.Impl.Serializers.WriteString.NullableClass();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((Counter) obj);
    }
    public bool Equals(Counter other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Name == other.Name && Equals(Tags, other.Tags) && Value == other.Value;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Name.GetHashCode();
        hash = hash * 31 + (Tags != null ? Tags.GetHashCode() : 0);
        hash = hash * 31 + Value.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("Counter (");
      using (printer.IndentCookie()) {
        printer.Print("name = "); Name.PrintEx(printer); printer.Println();
        printer.Print("tags = "); Tags.PrintEx(printer); printer.Println();
        printer.Print("value = "); Value.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:58</p>
  /// </summary>
  public sealed class CounterCollectionSession : RdBindableBase
  {
    //fields
    //public fields
    [NotNull] public string FilePath {get; private set;}
    public CounterFileFormat Format {get; private set;}
    public int RefreshInterval {get; private set;}
    [NotNull] public string Providers {get; private set;}
    [CanBeNull] public string Metrics {get; private set;}
    public int MaxTimeSeries {get; private set;}
    public int MaxHistograms {get; private set;}
    [CanBeNull] public int? Duration {get; private set;}
    
    //private fields
    //primary constructor
    public CounterCollectionSession(
      [NotNull] string filePath,
      CounterFileFormat format,
      int refreshInterval,
      [NotNull] string providers,
      [CanBeNull] string metrics,
      int maxTimeSeries,
      int maxHistograms,
      [CanBeNull] int? duration
    )
    {
      if (filePath == null) throw new ArgumentNullException("filePath");
      if (providers == null) throw new ArgumentNullException("providers");
      
      FilePath = filePath;
      Format = format;
      RefreshInterval = refreshInterval;
      Providers = providers;
      Metrics = metrics;
      MaxTimeSeries = maxTimeSeries;
      MaxHistograms = maxHistograms;
      Duration = duration;
    }
    //secondary constructor
    //deconstruct trait
    //statics
    
    public static CtxReadDelegate<CounterCollectionSession> Read = (ctx, reader) => 
    {
      var _id = RdId.Read(reader);
      var filePath = reader.ReadString();
      var format = (CounterFileFormat)reader.ReadInt();
      var refreshInterval = reader.ReadInt();
      var providers = reader.ReadString();
      var metrics = ReadStringNullable(ctx, reader);
      var maxTimeSeries = reader.ReadInt();
      var maxHistograms = reader.ReadInt();
      var duration = ReadIntNullable(ctx, reader);
      var _result = new CounterCollectionSession(filePath, format, refreshInterval, providers, metrics, maxTimeSeries, maxHistograms, duration).WithId(_id);
      return _result;
    };
    public static CtxReadDelegate<string> ReadStringNullable = JetBrains.Rd.Impl.Serializers.ReadString.NullableClass();
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static CtxWriteDelegate<CounterCollectionSession> Write = (ctx, writer, value) => 
    {
      value.RdId.Write(writer);
      writer.Write(value.FilePath);
      writer.Write((int)value.Format);
      writer.Write(value.RefreshInterval);
      writer.Write(value.Providers);
      WriteStringNullable(ctx, writer, value.Metrics);
      writer.Write(value.MaxTimeSeries);
      writer.Write(value.MaxHistograms);
      WriteIntNullable(ctx, writer, value.Duration);
    };
    public static  CtxWriteDelegate<string> WriteStringNullable = JetBrains.Rd.Impl.Serializers.WriteString.NullableClass();
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("CounterCollectionSession (");
      using (printer.IndentCookie()) {
        printer.Print("filePath = "); FilePath.PrintEx(printer); printer.Println();
        printer.Print("format = "); Format.PrintEx(printer); printer.Println();
        printer.Print("refreshInterval = "); RefreshInterval.PrintEx(printer); printer.Println();
        printer.Print("providers = "); Providers.PrintEx(printer); printer.Println();
        printer.Print("metrics = "); Metrics.PrintEx(printer); printer.Println();
        printer.Print("maxTimeSeries = "); MaxTimeSeries.PrintEx(printer); printer.Println();
        printer.Print("maxHistograms = "); MaxHistograms.PrintEx(printer); printer.Println();
        printer.Print("duration = "); Duration.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:60</p>
  /// </summary>
  public enum CounterFileFormat {
    Csv,
    Json
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:72</p>
  /// </summary>
  public sealed class CountersMonitoringSession : RdBindableBase
  {
    //fields
    //public fields
    [NotNull] public IViewableProperty<bool> Active => _Active;
    [NotNull] public IViewableProperty<int?> Duration => _Duration;
    [NotNull] public IViewableMap<string, Counter> Counters => _Counters;
    public int RefreshInterval {get; private set;}
    [NotNull] public string Providers {get; private set;}
    [CanBeNull] public string Metrics {get; private set;}
    public int MaxTimeSeries {get; private set;}
    public int MaxHistograms {get; private set;}
    
    //private fields
    [NotNull] private readonly RdProperty<bool> _Active;
    [NotNull] private readonly RdProperty<int?> _Duration;
    [NotNull] private readonly RdMap<string, Counter> _Counters;
    
    //primary constructor
    private CountersMonitoringSession(
      [NotNull] RdProperty<bool> active,
      [NotNull] RdProperty<int?> duration,
      [NotNull] RdMap<string, Counter> counters,
      int refreshInterval,
      [NotNull] string providers,
      [CanBeNull] string metrics,
      int maxTimeSeries,
      int maxHistograms
    )
    {
      if (active == null) throw new ArgumentNullException("active");
      if (duration == null) throw new ArgumentNullException("duration");
      if (counters == null) throw new ArgumentNullException("counters");
      if (providers == null) throw new ArgumentNullException("providers");
      
      _Active = active;
      _Duration = duration;
      _Counters = counters;
      RefreshInterval = refreshInterval;
      Providers = providers;
      Metrics = metrics;
      MaxTimeSeries = maxTimeSeries;
      MaxHistograms = maxHistograms;
      _Active.OptimizeNested = true;
      _Duration.OptimizeNested = true;
      _Counters.OptimizeNested = true;
      _Counters.Async = true;
      _Duration.ValueCanBeNull = true;
      BindableChildren.Add(new KeyValuePair<string, object>("active", _Active));
      BindableChildren.Add(new KeyValuePair<string, object>("duration", _Duration));
      BindableChildren.Add(new KeyValuePair<string, object>("counters", _Counters));
    }
    //secondary constructor
    public CountersMonitoringSession (
      int refreshInterval,
      [NotNull] string providers,
      [CanBeNull] string metrics,
      int maxTimeSeries,
      int maxHistograms
    ) : this (
      new RdProperty<bool>(JetBrains.Rd.Impl.Serializers.ReadBool, JetBrains.Rd.Impl.Serializers.WriteBool),
      new RdProperty<int?>(ReadIntNullable, WriteIntNullable),
      new RdMap<string, Counter>(JetBrains.Rd.Impl.Serializers.ReadString, JetBrains.Rd.Impl.Serializers.WriteString, Counter.Read, Counter.Write),
      refreshInterval,
      providers,
      metrics,
      maxTimeSeries,
      maxHistograms
    ) {}
    //deconstruct trait
    //statics
    
    public static CtxReadDelegate<CountersMonitoringSession> Read = (ctx, reader) => 
    {
      var _id = RdId.Read(reader);
      var active = RdProperty<bool>.Read(ctx, reader, JetBrains.Rd.Impl.Serializers.ReadBool, JetBrains.Rd.Impl.Serializers.WriteBool);
      var duration = RdProperty<int?>.Read(ctx, reader, ReadIntNullable, WriteIntNullable);
      var counters = RdMap<string, Counter>.Read(ctx, reader, JetBrains.Rd.Impl.Serializers.ReadString, JetBrains.Rd.Impl.Serializers.WriteString, Counter.Read, Counter.Write);
      var refreshInterval = reader.ReadInt();
      var providers = reader.ReadString();
      var metrics = ReadStringNullable(ctx, reader);
      var maxTimeSeries = reader.ReadInt();
      var maxHistograms = reader.ReadInt();
      var _result = new CountersMonitoringSession(active, duration, counters, refreshInterval, providers, metrics, maxTimeSeries, maxHistograms).WithId(_id);
      return _result;
    };
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    public static CtxReadDelegate<string> ReadStringNullable = JetBrains.Rd.Impl.Serializers.ReadString.NullableClass();
    
    public static CtxWriteDelegate<CountersMonitoringSession> Write = (ctx, writer, value) => 
    {
      value.RdId.Write(writer);
      RdProperty<bool>.Write(ctx, writer, value._Active);
      RdProperty<int?>.Write(ctx, writer, value._Duration);
      RdMap<string, Counter>.Write(ctx, writer, value._Counters);
      writer.Write(value.RefreshInterval);
      writer.Write(value.Providers);
      WriteStringNullable(ctx, writer, value.Metrics);
      writer.Write(value.MaxTimeSeries);
      writer.Write(value.MaxHistograms);
    };
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    public static  CtxWriteDelegate<string> WriteStringNullable = JetBrains.Rd.Impl.Serializers.WriteString.NullableClass();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("CountersMonitoringSession (");
      using (printer.IndentCookie()) {
        printer.Print("active = "); _Active.PrintEx(printer); printer.Println();
        printer.Print("duration = "); _Duration.PrintEx(printer); printer.Println();
        printer.Print("counters = "); _Counters.PrintEx(printer); printer.Println();
        printer.Print("refreshInterval = "); RefreshInterval.PrintEx(printer); printer.Println();
        printer.Print("providers = "); Providers.PrintEx(printer); printer.Println();
        printer.Print("metrics = "); Metrics.PrintEx(printer); printer.Println();
        printer.Print("maxTimeSeries = "); MaxTimeSeries.PrintEx(printer); printer.Println();
        printer.Print("maxHistograms = "); MaxHistograms.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:109</p>
  /// </summary>
  public sealed class DumpCollectionResult : IPrintable, IEquatable<DumpCollectionResult>
  {
    //fields
    //public fields
    [NotNull] public string FilePath {get; private set;}
    
    //private fields
    //primary constructor
    public DumpCollectionResult(
      [NotNull] string filePath
    )
    {
      if (filePath == null) throw new ArgumentNullException("filePath");
      
      FilePath = filePath;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string filePath)
    {
      filePath = FilePath;
    }
    //statics
    
    public static CtxReadDelegate<DumpCollectionResult> Read = (ctx, reader) => 
    {
      var filePath = reader.ReadString();
      var _result = new DumpCollectionResult(filePath);
      return _result;
    };
    
    public static CtxWriteDelegate<DumpCollectionResult> Write = (ctx, writer, value) => 
    {
      writer.Write(value.FilePath);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((DumpCollectionResult) obj);
    }
    public bool Equals(DumpCollectionResult other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return FilePath == other.FilePath;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + FilePath.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("DumpCollectionResult (");
      using (printer.IndentCookie()) {
        printer.Print("filePath = "); FilePath.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:100</p>
  /// </summary>
  public enum DumpType {
    Full,
    Heap,
    Triage,
    Mini
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:40</p>
  /// </summary>
  public sealed class GcEvent : IPrintable, IEquatable<GcEvent>
  {
    //fields
    //public fields
    public int Number {get; private set;}
    [NotNull] public string Generation {get; private set;}
    [NotNull] public string Reason {get; private set;}
    public double PauseDuration {get; private set;}
    public double Peak {get; private set;}
    public double After {get; private set;}
    public double Ratio {get; private set;}
    public double Promoted {get; private set;}
    public double Allocated {get; private set;}
    public double AllocationRate {get; private set;}
    public double SizeGen0 {get; private set;}
    public double SizeGen1 {get; private set;}
    public double SizeGen2 {get; private set;}
    public double SizeLoh {get; private set;}
    public int PinnedObjects {get; private set;}
    
    //private fields
    //primary constructor
    public GcEvent(
      int number,
      [NotNull] string generation,
      [NotNull] string reason,
      double pauseDuration,
      double peak,
      double after,
      double ratio,
      double promoted,
      double allocated,
      double allocationRate,
      double sizeGen0,
      double sizeGen1,
      double sizeGen2,
      double sizeLoh,
      int pinnedObjects
    )
    {
      if (generation == null) throw new ArgumentNullException("generation");
      if (reason == null) throw new ArgumentNullException("reason");
      
      Number = number;
      Generation = generation;
      Reason = reason;
      PauseDuration = pauseDuration;
      Peak = peak;
      After = after;
      Ratio = ratio;
      Promoted = promoted;
      Allocated = allocated;
      AllocationRate = allocationRate;
      SizeGen0 = sizeGen0;
      SizeGen1 = sizeGen1;
      SizeGen2 = sizeGen2;
      SizeLoh = sizeLoh;
      PinnedObjects = pinnedObjects;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct(out int number, [NotNull] out string generation, [NotNull] out string reason, out double pauseDuration, out double peak, out double after, out double ratio, out double promoted, out double allocated, out double allocationRate, out double sizeGen0, out double sizeGen1, out double sizeGen2, out double sizeLoh, out int pinnedObjects)
    {
      number = Number;
      generation = Generation;
      reason = Reason;
      pauseDuration = PauseDuration;
      peak = Peak;
      after = After;
      ratio = Ratio;
      promoted = Promoted;
      allocated = Allocated;
      allocationRate = AllocationRate;
      sizeGen0 = SizeGen0;
      sizeGen1 = SizeGen1;
      sizeGen2 = SizeGen2;
      sizeLoh = SizeLoh;
      pinnedObjects = PinnedObjects;
    }
    //statics
    
    public static CtxReadDelegate<GcEvent> Read = (ctx, reader) => 
    {
      var number = reader.ReadInt();
      var generation = reader.ReadString();
      var reason = reader.ReadString();
      var pauseDuration = reader.ReadDouble();
      var peak = reader.ReadDouble();
      var after = reader.ReadDouble();
      var ratio = reader.ReadDouble();
      var promoted = reader.ReadDouble();
      var allocated = reader.ReadDouble();
      var allocationRate = reader.ReadDouble();
      var sizeGen0 = reader.ReadDouble();
      var sizeGen1 = reader.ReadDouble();
      var sizeGen2 = reader.ReadDouble();
      var sizeLoh = reader.ReadDouble();
      var pinnedObjects = reader.ReadInt();
      var _result = new GcEvent(number, generation, reason, pauseDuration, peak, after, ratio, promoted, allocated, allocationRate, sizeGen0, sizeGen1, sizeGen2, sizeLoh, pinnedObjects);
      return _result;
    };
    
    public static CtxWriteDelegate<GcEvent> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Number);
      writer.Write(value.Generation);
      writer.Write(value.Reason);
      writer.Write(value.PauseDuration);
      writer.Write(value.Peak);
      writer.Write(value.After);
      writer.Write(value.Ratio);
      writer.Write(value.Promoted);
      writer.Write(value.Allocated);
      writer.Write(value.AllocationRate);
      writer.Write(value.SizeGen0);
      writer.Write(value.SizeGen1);
      writer.Write(value.SizeGen2);
      writer.Write(value.SizeLoh);
      writer.Write(value.PinnedObjects);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((GcEvent) obj);
    }
    public bool Equals(GcEvent other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Number == other.Number && Generation == other.Generation && Reason == other.Reason && PauseDuration == other.PauseDuration && Peak == other.Peak && After == other.After && Ratio == other.Ratio && Promoted == other.Promoted && Allocated == other.Allocated && AllocationRate == other.AllocationRate && SizeGen0 == other.SizeGen0 && SizeGen1 == other.SizeGen1 && SizeGen2 == other.SizeGen2 && SizeLoh == other.SizeLoh && PinnedObjects == other.PinnedObjects;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Number.GetHashCode();
        hash = hash * 31 + Generation.GetHashCode();
        hash = hash * 31 + Reason.GetHashCode();
        hash = hash * 31 + PauseDuration.GetHashCode();
        hash = hash * 31 + Peak.GetHashCode();
        hash = hash * 31 + After.GetHashCode();
        hash = hash * 31 + Ratio.GetHashCode();
        hash = hash * 31 + Promoted.GetHashCode();
        hash = hash * 31 + Allocated.GetHashCode();
        hash = hash * 31 + AllocationRate.GetHashCode();
        hash = hash * 31 + SizeGen0.GetHashCode();
        hash = hash * 31 + SizeGen1.GetHashCode();
        hash = hash * 31 + SizeGen2.GetHashCode();
        hash = hash * 31 + SizeLoh.GetHashCode();
        hash = hash * 31 + PinnedObjects.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("GcEvent (");
      using (printer.IndentCookie()) {
        printer.Print("number = "); Number.PrintEx(printer); printer.Println();
        printer.Print("generation = "); Generation.PrintEx(printer); printer.Println();
        printer.Print("reason = "); Reason.PrintEx(printer); printer.Println();
        printer.Print("pauseDuration = "); PauseDuration.PrintEx(printer); printer.Println();
        printer.Print("peak = "); Peak.PrintEx(printer); printer.Println();
        printer.Print("after = "); After.PrintEx(printer); printer.Println();
        printer.Print("ratio = "); Ratio.PrintEx(printer); printer.Println();
        printer.Print("promoted = "); Promoted.PrintEx(printer); printer.Println();
        printer.Print("allocated = "); Allocated.PrintEx(printer); printer.Println();
        printer.Print("allocationRate = "); AllocationRate.PrintEx(printer); printer.Println();
        printer.Print("sizeGen0 = "); SizeGen0.PrintEx(printer); printer.Println();
        printer.Print("sizeGen1 = "); SizeGen1.PrintEx(printer); printer.Println();
        printer.Print("sizeGen2 = "); SizeGen2.PrintEx(printer); printer.Println();
        printer.Print("sizeLoh = "); SizeLoh.PrintEx(printer); printer.Println();
        printer.Print("pinnedObjects = "); PinnedObjects.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:26</p>
  /// </summary>
  public sealed class GcEventsMonitoringSession : RdBindableBase
  {
    //fields
    //public fields
    public int Pid {get; private set;}
    [NotNull] public IViewableProperty<bool> Active => _Active;
    [NotNull] public ISignal<GcEvent> GcHappened => _GcHappened;
    [NotNull] public IRdEndpoint<int?, Unit> Monitor => _Monitor;
    [NotNull] public ISignal<Unit> Close => _Close;
    
    //private fields
    [NotNull] private readonly RdProperty<bool> _Active;
    [NotNull] private readonly RdSignal<GcEvent> _GcHappened;
    [NotNull] private readonly RdCall<int?, Unit> _Monitor;
    [NotNull] private readonly RdSignal<Unit> _Close;
    
    //primary constructor
    private GcEventsMonitoringSession(
      int pid,
      [NotNull] RdProperty<bool> active,
      [NotNull] RdSignal<GcEvent> gcHappened,
      [NotNull] RdCall<int?, Unit> monitor,
      [NotNull] RdSignal<Unit> close
    )
    {
      if (active == null) throw new ArgumentNullException("active");
      if (gcHappened == null) throw new ArgumentNullException("gcHappened");
      if (monitor == null) throw new ArgumentNullException("monitor");
      if (close == null) throw new ArgumentNullException("close");
      
      Pid = pid;
      _Active = active;
      _GcHappened = gcHappened;
      _Monitor = monitor;
      _Close = close;
      _Active.OptimizeNested = true;
      _Active.Async = true;
      _GcHappened.Async = true;
      _Close.Async = true;
      _Monitor.ValueCanBeNull = true;
      BindableChildren.Add(new KeyValuePair<string, object>("active", _Active));
      BindableChildren.Add(new KeyValuePair<string, object>("gcHappened", _GcHappened));
      BindableChildren.Add(new KeyValuePair<string, object>("monitor", _Monitor));
      BindableChildren.Add(new KeyValuePair<string, object>("close", _Close));
    }
    //secondary constructor
    public GcEventsMonitoringSession (
      int pid
    ) : this (
      pid,
      new RdProperty<bool>(JetBrains.Rd.Impl.Serializers.ReadBool, JetBrains.Rd.Impl.Serializers.WriteBool),
      new RdSignal<GcEvent>(GcEvent.Read, GcEvent.Write),
      new RdCall<int?, Unit>(ReadIntNullable, WriteIntNullable, JetBrains.Rd.Impl.Serializers.ReadVoid, JetBrains.Rd.Impl.Serializers.WriteVoid),
      new RdSignal<Unit>(JetBrains.Rd.Impl.Serializers.ReadVoid, JetBrains.Rd.Impl.Serializers.WriteVoid)
    ) {}
    //deconstruct trait
    //statics
    
    public static CtxReadDelegate<GcEventsMonitoringSession> Read = (ctx, reader) => 
    {
      var _id = RdId.Read(reader);
      var pid = reader.ReadInt();
      var active = RdProperty<bool>.Read(ctx, reader, JetBrains.Rd.Impl.Serializers.ReadBool, JetBrains.Rd.Impl.Serializers.WriteBool);
      var gcHappened = RdSignal<GcEvent>.Read(ctx, reader, GcEvent.Read, GcEvent.Write);
      var monitor = RdCall<int?, Unit>.Read(ctx, reader, ReadIntNullable, WriteIntNullable, JetBrains.Rd.Impl.Serializers.ReadVoid, JetBrains.Rd.Impl.Serializers.WriteVoid);
      var close = RdSignal<Unit>.Read(ctx, reader, JetBrains.Rd.Impl.Serializers.ReadVoid, JetBrains.Rd.Impl.Serializers.WriteVoid);
      var _result = new GcEventsMonitoringSession(pid, active, gcHappened, monitor, close).WithId(_id);
      return _result;
    };
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static CtxWriteDelegate<GcEventsMonitoringSession> Write = (ctx, writer, value) => 
    {
      value.RdId.Write(writer);
      writer.Write(value.Pid);
      RdProperty<bool>.Write(ctx, writer, value._Active);
      RdSignal<GcEvent>.Write(ctx, writer, value._GcHappened);
      RdCall<int?, Unit>.Write(ctx, writer, value._Monitor);
      RdSignal<Unit>.Write(ctx, writer, value._Close);
    };
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("GcEventsMonitoringSession (");
      using (printer.IndentCookie()) {
        printer.Print("pid = "); Pid.PrintEx(printer); printer.Println();
        printer.Print("active = "); _Active.PrintEx(printer); printer.Println();
        printer.Print("gcHappened = "); _GcHappened.PrintEx(printer); printer.Println();
        printer.Print("monitor = "); _Monitor.PrintEx(printer); printer.Println();
        printer.Print("close = "); _Close.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:125</p>
  /// </summary>
  public sealed class MonitorGcEventsCommand : IPrintable, IEquatable<MonitorGcEventsCommand>
  {
    //fields
    //public fields
    public int Pid {get; private set;}
    [CanBeNull] public int? Duration {get; private set;}
    
    //private fields
    //primary constructor
    public MonitorGcEventsCommand(
      int pid,
      [CanBeNull] int? duration
    )
    {
      Pid = pid;
      Duration = duration;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct(out int pid, [CanBeNull] out int? duration)
    {
      pid = Pid;
      duration = Duration;
    }
    //statics
    
    public static CtxReadDelegate<MonitorGcEventsCommand> Read = (ctx, reader) => 
    {
      var pid = reader.ReadInt();
      var duration = ReadIntNullable(ctx, reader);
      var _result = new MonitorGcEventsCommand(pid, duration);
      return _result;
    };
    public static CtxReadDelegate<int?> ReadIntNullable = JetBrains.Rd.Impl.Serializers.ReadInt.NullableStruct();
    
    public static CtxWriteDelegate<MonitorGcEventsCommand> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Pid);
      WriteIntNullable(ctx, writer, value.Duration);
    };
    public static  CtxWriteDelegate<int?> WriteIntNullable = JetBrains.Rd.Impl.Serializers.WriteInt.NullableStruct();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((MonitorGcEventsCommand) obj);
    }
    public bool Equals(MonitorGcEventsCommand other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Pid == other.Pid && Equals(Duration, other.Duration);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Pid.GetHashCode();
        hash = hash * 31 + (Duration != null ? Duration.GetHashCode() : 0);
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("MonitorGcEventsCommand (");
      using (printer.IndentCookie()) {
        printer.Print("pid = "); Pid.PrintEx(printer); printer.Println();
        printer.Print("duration = "); Duration.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:11</p>
  /// </summary>
  public sealed class ProcessInfo : IPrintable, IEquatable<ProcessInfo>
  {
    //fields
    //public fields
    public int ProcessId {get; private set;}
    [NotNull] public string ProcessName {get; private set;}
    [CanBeNull] public string Filename {get; private set;}
    [CanBeNull] public string StartTime {get; private set;}
    [CanBeNull] public string CommandLine {get; private set;}
    [CanBeNull] public string OperatingSystem {get; private set;}
    [CanBeNull] public string ProcessArchitecture {get; private set;}
    
    //private fields
    //primary constructor
    public ProcessInfo(
      int processId,
      [NotNull] string processName,
      [CanBeNull] string filename,
      [CanBeNull] string startTime,
      [CanBeNull] string commandLine,
      [CanBeNull] string operatingSystem,
      [CanBeNull] string processArchitecture
    )
    {
      if (processName == null) throw new ArgumentNullException("processName");
      
      ProcessId = processId;
      ProcessName = processName;
      Filename = filename;
      StartTime = startTime;
      CommandLine = commandLine;
      OperatingSystem = operatingSystem;
      ProcessArchitecture = processArchitecture;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct(out int processId, [NotNull] out string processName, [CanBeNull] out string filename, [CanBeNull] out string startTime, [CanBeNull] out string commandLine, [CanBeNull] out string operatingSystem, [CanBeNull] out string processArchitecture)
    {
      processId = ProcessId;
      processName = ProcessName;
      filename = Filename;
      startTime = StartTime;
      commandLine = CommandLine;
      operatingSystem = OperatingSystem;
      processArchitecture = ProcessArchitecture;
    }
    //statics
    
    public static CtxReadDelegate<ProcessInfo> Read = (ctx, reader) => 
    {
      var processId = reader.ReadInt();
      var processName = reader.ReadString();
      var filename = ReadStringNullable(ctx, reader);
      var startTime = ReadStringNullable(ctx, reader);
      var commandLine = ReadStringNullable(ctx, reader);
      var operatingSystem = ReadStringNullable(ctx, reader);
      var processArchitecture = ReadStringNullable(ctx, reader);
      var _result = new ProcessInfo(processId, processName, filename, startTime, commandLine, operatingSystem, processArchitecture);
      return _result;
    };
    public static CtxReadDelegate<string> ReadStringNullable = JetBrains.Rd.Impl.Serializers.ReadString.NullableClass();
    
    public static CtxWriteDelegate<ProcessInfo> Write = (ctx, writer, value) => 
    {
      writer.Write(value.ProcessId);
      writer.Write(value.ProcessName);
      WriteStringNullable(ctx, writer, value.Filename);
      WriteStringNullable(ctx, writer, value.StartTime);
      WriteStringNullable(ctx, writer, value.CommandLine);
      WriteStringNullable(ctx, writer, value.OperatingSystem);
      WriteStringNullable(ctx, writer, value.ProcessArchitecture);
    };
    public static  CtxWriteDelegate<string> WriteStringNullable = JetBrains.Rd.Impl.Serializers.WriteString.NullableClass();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((ProcessInfo) obj);
    }
    public bool Equals(ProcessInfo other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return ProcessId == other.ProcessId && ProcessName == other.ProcessName && Equals(Filename, other.Filename) && Equals(StartTime, other.StartTime) && Equals(CommandLine, other.CommandLine) && Equals(OperatingSystem, other.OperatingSystem) && Equals(ProcessArchitecture, other.ProcessArchitecture);
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + ProcessId.GetHashCode();
        hash = hash * 31 + ProcessName.GetHashCode();
        hash = hash * 31 + (Filename != null ? Filename.GetHashCode() : 0);
        hash = hash * 31 + (StartTime != null ? StartTime.GetHashCode() : 0);
        hash = hash * 31 + (CommandLine != null ? CommandLine.GetHashCode() : 0);
        hash = hash * 31 + (OperatingSystem != null ? OperatingSystem.GetHashCode() : 0);
        hash = hash * 31 + (ProcessArchitecture != null ? ProcessArchitecture.GetHashCode() : 0);
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("ProcessInfo (");
      using (printer.IndentCookie()) {
        printer.Print("processId = "); ProcessId.PrintEx(printer); printer.Println();
        printer.Print("processName = "); ProcessName.PrintEx(printer); printer.Println();
        printer.Print("filename = "); Filename.PrintEx(printer); printer.Println();
        printer.Print("startTime = "); StartTime.PrintEx(printer); printer.Println();
        printer.Print("commandLine = "); CommandLine.PrintEx(printer); printer.Println();
        printer.Print("operatingSystem = "); OperatingSystem.PrintEx(printer); printer.Println();
        printer.Print("processArchitecture = "); ProcessArchitecture.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:21</p>
  /// </summary>
  public sealed class ProcessList : RdBindableBase
  {
    //fields
    //public fields
    [NotNull] public IViewableList<ProcessInfo> Items => _Items;
    [NotNull] public ISource<Unit> Refresh => _Refresh;
    
    //private fields
    [NotNull] private readonly RdList<ProcessInfo> _Items;
    [NotNull] private readonly RdSignal<Unit> _Refresh;
    
    //primary constructor
    private ProcessList(
      [NotNull] RdList<ProcessInfo> items,
      [NotNull] RdSignal<Unit> refresh
    )
    {
      if (items == null) throw new ArgumentNullException("items");
      if (refresh == null) throw new ArgumentNullException("refresh");
      
      _Items = items;
      _Refresh = refresh;
      _Items.OptimizeNested = true;
      BindableChildren.Add(new KeyValuePair<string, object>("items", _Items));
      BindableChildren.Add(new KeyValuePair<string, object>("refresh", _Refresh));
    }
    //secondary constructor
    public ProcessList (
    ) : this (
      new RdList<ProcessInfo>(ProcessInfo.Read, ProcessInfo.Write),
      new RdSignal<Unit>(JetBrains.Rd.Impl.Serializers.ReadVoid, JetBrains.Rd.Impl.Serializers.WriteVoid)
    ) {}
    //deconstruct trait
    //statics
    
    public static CtxReadDelegate<ProcessList> Read = (ctx, reader) => 
    {
      var _id = RdId.Read(reader);
      var items = RdList<ProcessInfo>.Read(ctx, reader, ProcessInfo.Read, ProcessInfo.Write);
      var refresh = RdSignal<Unit>.Read(ctx, reader, JetBrains.Rd.Impl.Serializers.ReadVoid, JetBrains.Rd.Impl.Serializers.WriteVoid);
      var _result = new ProcessList(items, refresh).WithId(_id);
      return _result;
    };
    
    public static CtxWriteDelegate<ProcessList> Write = (ctx, writer, value) => 
    {
      value.RdId.Write(writer);
      RdList<ProcessInfo>.Write(ctx, writer, value._Items);
      RdSignal<Unit>.Write(ctx, writer, value._Refresh);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("ProcessList (");
      using (printer.IndentCookie()) {
        printer.Print("items = "); _Items.PrintEx(printer); printer.Println();
        printer.Print("refresh = "); _Refresh.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:139</p>
  /// </summary>
  public enum TracingProfile {
    None,
    CpuSampling,
    GcVerbose,
    GcCollect
  }
  
  
  /// <summary>
  /// <p>Generated from: DiagnosticsHostModel.kt:132</p>
  /// </summary>
  public sealed class TriggerGcCommand : IPrintable, IEquatable<TriggerGcCommand>
  {
    //fields
    //public fields
    public int Pid {get; private set;}
    
    //private fields
    //primary constructor
    public TriggerGcCommand(
      int pid
    )
    {
      Pid = pid;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct(out int pid)
    {
      pid = Pid;
    }
    //statics
    
    public static CtxReadDelegate<TriggerGcCommand> Read = (ctx, reader) => 
    {
      var pid = reader.ReadInt();
      var _result = new TriggerGcCommand(pid);
      return _result;
    };
    
    public static CtxWriteDelegate<TriggerGcCommand> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Pid);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((TriggerGcCommand) obj);
    }
    public bool Equals(TriggerGcCommand other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Pid == other.Pid;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Pid.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("TriggerGcCommand (");
      using (printer.IndentCookie()) {
        printer.Print("pid = "); Pid.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
}
